Finora abbiamo discusso alcuni stack-based buffer overflows, e abbiamo già visto che un programma vulnerabile può permettere a un attaccante di modificare variabili locali, perché le variabili locali sono allocate sullo stack.
Se c’è un buffer overflow sullo stack, l’attaccante può cambiare il valore di alcune variabili, e questo a volte basta per cambiare il comportamento del programma.
Se puoi sostituire il return address, che è anch’esso salvato sullo stack, puoi controllare ciò che il programma esegue, e nei vecchi scenari discussi con la shellcoding, l’attaccante può iniettare nuovo codice e farlo eseguire al programma.

Questo però non è molto realistico nei sistemi operativi moderni: non puoi — con le tecniche discusse — iniettare nuovo codice in un processo e farlo eseguire, perché nelle OS moderne lo stack non è eseguibile.
Quindi anche se inietti codice, non puoi eseguirlo: otterresti una segmentation fault, perché le pagine dello stack sono marcate come non-executable.


## ASLR

L’ASLR è una mitigazione di sicurezza che randomizza l’indirizzo base dei programmi.
Significa che, se un programma supporta l’ASLR, ogni volta che lo esegui, il programma viene mappato a un indirizzo diverso nello process address space.

Tuttavia, il programma deve supportare l’ASLR.
Questo significa che, per essere caricato a un indirizzo casuale, il programma deve essere compilato come PIE (Position Independent Executable).
Position independent significa che il codice può essere eseguito a qualunque indirizzo, letteralmente.

Se il programma non è PIE, il sistema operativo non può randomizzare il suo indirizzo base.
Anche se l’ASLR è abilitato a livello di sistema operativo, se il programma è stato compilato senza position independent code, non può essere randomizzato.


Per vedere se un programma è PIE o non PIE puoi usare
- `file`
- `checksec --file /bin/ls` 


### superare la protezione di sicurezza ASLR

- PLT (Procedure Linkage Table): È una sezione di codice all'interno del programma principale. Quando il programma chiama una funzione esterna (come printf in libc), esegue prima un piccolo stub di codice che si trova nella PLT.
- GOT (Global Offset Table): È una tabella di puntatori a dati e funzioni esterne. Lo stub PLT di una funzione (es. printf) legge il puntatore alla sua vera implementazione che è memorizzato nella GOT.


la GOT è la chiave per "sconfiggere" l'ASLR di libc:

- Se l'eseguibile è PIE, anche la GOT viene randomizzata. L'attaccante deve quindi prima trovare un indirizzo leakato del programma per calcolare la base dell'eseguibile, e da lì calcolare l'indirizzo randomizzato della GOT (dato che l'offset tra la base e la GOT è fisso)
- GOT Contiene l'Indirizzo Reale: Poiché il programma deve chiamare la funzione printf in libc, la GOT deve contenere l'indirizzo reale e corrente della funzione printf all'interno della libc caricata casualmente.
- Leak del Puntatore: Se un attaccante sfrutta una vulnerabilità (ad esempio, una format string vulnerability o un buffer overflow con capacità di lettura) per leggere il contenuto della GOT per una funzione come printf, ottiene l'indirizzo esatto di printf per quella specifica esecuzione.
- Calcolo dell'Indirizzo Base (Base Address Calculation):Gli sviluppatori conoscono l'offset (la distanza fissa in byte) tra l'inizio di libc e la funzione printf.L'attaccante usa la seguente formula per trovare l'indirizzo base di libc per quell'esecuzione:
  `addr_libc_base = addr_printf - offset_printf` 

- Una volta che l'attaccante ha l'indirizzo base di libc, può aggiungere l'offset conosciuto di qualsiasi altra funzione di libc (es. system) per calcolare il suo indirizzo esatto. In questo modo, de-randomizza la libreria libc e può reindirizzare il flusso di esecuzione a funzioni pericolose, anche se l'ASLR è attivo.

Nota: Ovviamente questo indirizzo non sarà valido in altre esecuzioni


Con pwntools, avendo un ELF, puoi usare:


- `.plt.name` per ottenere l’indirizzo o l’offset della voce PLT
- `.got.name` per ottenere l’indirizzo o l’offset della voce GOT
- `elf.sym.name` per ottenere indirizzi/simboli

Se il programma è non-PIE, ottieni l’indirizzo reale.
Se è PIE, ottieni l’offset dal base address, che cambia sempre.




# format string vulnerability

## fmtsrt_files/example{32,64}

Quando printf viene chiamato con un solo argomento (name in questo caso), lo interpreta come stringa di formato, ovvero una sequenza che può contenere specificatori di formato (%x, %s, %n, ecc.). Se l'utente inserisce tali specificatori, printf tenterà di accedere alla memoria o scrivere in essa, anche se il programma non ha previsto ciò.

Exploit32: `%10$x` # richiesta di stampare 10 valori dalla pila.
Exploit64: `%8$x`

Se l'utente inserisce `%s`, printf cercherà di leggere un puntatore dalla pila e poi dereferenzierà quel puntatore per stampare la stringa a cui punta.
Ora, in questo caso il programma potrebbe crashare, perché se chiediamo di stampare una stringa puntata da qualcosa che non è un puntatore valido, il programma proverà a dereferenziare quel “puntatore” e otterrà una segmentation fault.


Exploit32: `%11$s`  # richiesta di stampare una stringa puntata dal valore in posizione 11 della pila.
Exploit64: `%9$s`


Il programma non ha un puntatore sullo stack che punti alla stringa `other_secret`.
Quindi, in condizioni normali, printf non può stamparla, perché:

- `printf("%x")` legge solo dallo stack.
- I puntatori alla .rodata (come `other_secret`) NON sono nello stack.
- Non possiamo far leggere a printf un indirizzo arbitrario che NON si trovi nello stack.

Quindi l’idea è:

Se il puntatore non è sullo stack ce lo mettiamo noi!

Qui che entra in gioco il buffer name.

- noi possiamo controllare completamente i 16 byte di name,

Il primo passo è capire a che slot si trova  `name[]` nello stack.

- Inviamo una stringa facilmente riconoscibile `aaaa` (in hex `61616161`) come name
- Usiamo `%x` per leggere vari valori dallo stack, finché non vediamo `61616161` stampato.
- Contiamo quanti `%x` abbiamo usato per arrivare a quel valore: quello è l’indice di name nello stack.

Esempio

```sh
What's your name? aaaaaaaa%6$x  -->  nota: ho un limite di 16 byte per stdinput
Hi, 61616161 --> stapa il sesto slot dello stack che contiene aaaa
```

Okey, quindi l'ultimo `a` è in posizione 7 nello stack.
Ora possiamo leggere il contenuto di name usando `%7$x`.

adesso vogliamo scrivere l'indirizzo di `other_secret` dentro `name`, in modo che printf possa leggerlo e dereferenziare quel puntatore.

Exploit32:

- Troviamo l’indirizzo di  `other_secret ` nell’ELF (basta leggere la symbol tabl con pwntools)
- Costruisce un payload:
- `%7$s 0x0804c040` --> occupa 6 byte e prima abbimao detto che con 6 byte siano allo slot 7 nello stack
- dove `0x0804c040` è l’indirizzo di `other_secret`
  
Quando printf legge questo payload:

- legge il puntatore `0x0804c040` da name (posizione 7 nello stack)
- dereferenzia quel puntatore
- stampa la stringa a cui punta `other_secret`


Nella versione 64 bit, invece, serve “riempire lo slot” con dati extra per allineare:

- uno slot = 8 byte
- quindi aggiungo 4 caratteri inutili, poi il pointer


Esempio visivo di Stacke di slot

```sh
Slot 7: |r|-|-|-|
Slot 6: |f|e|d|e|
```




## Mitigazioni

Per sfruttare vulnerabilità di questo tipo, che offrono così tanto potere, sono necessari tre ingredienti fondamentali:

1. **Buffer Overflow non rilevato --> stack canaries/cookies**: Il programma non deve rilevare l'attacco. Se il programma rileva che c’è stato un attacco, può semplicemente terminare l’esecuzione, impedendo ulteriori exploit.
2. **Stack eseguibile --> NX/DEP/W^X**: Nei nostri esempi, il buffer si trovava sullo stack. Sovrascrivendo il buffer, si scriveva codice direttamente nello stack, che deve essere eseguibile per permettere l’esecuzione del payload.
3. **Indirizzo prevedibile --> ASLR**: L’attaccante deve essere in grado di predire l’indirizzo in cui il codice è stato scritto dal programma. Per eseguire il codice, è necessario conoscere il suo indirizzo.


Nei moderni sistemi operativi, tutte e tre queste condizioni sono negate di default, rendendo gli attacchi di buffer overflow molto più difficili (anche se non impossibili). Ad esempio, compilando un programma con GCC o Clang, le seguenti protezioni sono attive di default:


Lo **stack canaries/cookies** [canary.png] è un valore intero posizionato prima del return address nello stack. La sua funzione è rilevare sovrascritture dello stack. Ecco alcune caratteristiche principali:

- **Byte a zero**: Tipicamente contiene un byte a zero, poiché molte funzioni di copia stringhe in C (come `strcpy`) si fermano al primo `\0`, impedendo la sovrascrittura dei byte successivi.
- **Casualità**: Il canary deve contenere byte casuali. Se l’attaccante può prevedere il valore del canary, può riscriverlo identico, aggirando la protezione.


Oggi, la protezione dello stack è abilitata di default e può essere configurata a diversi livelli:


- **Stack Protector**: Protegge solo le funzioni che contengono array di tipo `char`.
- **Stack Protector Strong**: Protegge quasi tutte le funzioni.

Questi livelli aggiungono controlli all’ingresso e all’uscita delle funzioni.

### Stack Canary

- Il valore del canary è fornito dal sistema operativo.
- A ogni esecuzione (`exec`), il sistema genera un nuovo numero casuale e lo salva in una struttura speciale accessibile tramite un registro di segmento:
  - **`gs`**: Per eseguibili a 32-bit su Linux.
  - **`fs`**: Per eseguibili a 64-bit su Linux.
  - (Questi registri sono invertiti su Windows.)

Prima di ritornare da una funzione, il programma carica il valore salvato nello stack e lo confronta con il valore originale. Se i due valori differiscono, il programma chiama la funzione `__stack_chk_fail`, che stampa un errore e termina l’esecuzione.

#### tbg_files/the_best_game/bg0_docker/best_game0

Programma compoi ocn solo mitigazione sull stack canary

```sh
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```

Possimao notare un comportamento anomalo del programma qunado si tenta di fornire un input eccessivamente lungo (buffer overflow):

- Inserendo una stringa molto lunga (es. aaaaaaaa...), il programma non crasha
- Alla richiesta successiva di input, anche se si fornisce un nome corretto (es. HZD), il programma termina con l'errore `stack smashing detected` e viene interrotto (abbiamo sovrascritto il canary).

Esiste una funzione `spawn_Shell` che spawna la shell.
Ma non sappiamo dove sia il Canary perché forse dopo il buffer ci sono altre cose, e altre cose ancora, quindi dobbiamo raggiungere l’indirizzo giusto per arrivare al Canary e lasciarlo intatto sovrascrivendolo.

La vulnerabilità è che il programma legge un nome dentro un buffer di dimensione fissa. 
Poiché il codice è compilato con il canary ma senza NX e senza PIE, possiamo sfruttarlo come leak

Il ciclo nel programma è utile, perché al primo tentativo leakiamo il canary; al secondo tentativo sovrascriviamo il canary con il valore recuperato e possiamo sovrascrivere anche il return address. 

Cerchaimo il canry:

1. Con **DEBUG+GDB**

Essendo il Canary radnomico apriamo due finestre per debuggare 

- una con DEBUG
- una con GDB

Con pwntools apro il programma in DEBUG e gli mando `'a'*32`

```sh
./exploit-template.py DEBUG GDB
gef➤  canary
The canary of process 199637 is at 0xffd49d8b, value is 0x3861fc00

ATTENZIONE: 0xffd49d8b non è l indirizzo del canary sullo stack
```

- Siccome il buffer è [32] 
- e pwntool aggiunge una newline `\n` alla fine 

Vado a sovrascrivere il temrinatore null `0x00` del canary con `0x0a` (carattere '\n').
Il dump di print mostra i 3 byte finali del canary come `fc 61 38` (little-endian).

**vedere il file gets-fgets-read-md**

1. Con **ghidra**
Quindi possiamo fare un sacco di tentativi oppure possiamo semplicemente aprire Ghidra e controllare il codice.
Su ghidra all interno della funzione quiz()

troviamo `mov eax, gs:[0x14]` che
praticamente non viene mai usato se non in questi casi, quindi quello è il valore.
Ed è scritto in `ebp - 0xc.` --> lo vediamo in basso a destra su ghidra 

- è l offset rispetto a ebp

La read() è ine  `ebp - 0x2c.`  
Quindi se siamo a -0x2c e dobbiamo raggiungere -0x0c ci vorranno 0x20 byte

Facciamo l'exploit `pwn-best_game0.py`


#### tbg_files/the_best_game/bg0_pro_docker/best_game0_pro

- Stesse mitigazioni 
- ma non abbiamo una funzione `spawn_shell` pronta.
 
```sh
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```

**Metodo facile**

sfruttamentiamo `call esp` a `0x080488eb`. Per cercare tali istruzioni è possibile utilizzare:

```sh
pip3 install ropper
ropper -f best_game0_pro --type jop --search '%esp%' --quality 1
```

Questo è il metodo più semplice in assoluto nel binary exploitation su x86 quando il binario è NO PIE, cioè quando la .text è fissa.

**Metodo più difficile**

b *(quiz+1)
run 
telescope

Inoltre possiamo notare un’altra cosa, il fatto che il base pointer…
Ok, ricordate che il base pointer è EBP, quindi è il frame pointer della funzione, e ogni funzione imposta il proprio frame pointer e, prima di farlo, salva il base pointer della chiamante.

Quindi, sostanzialmente, all’inizio di ogni frame abbiamo il frame pointer salvato, che è il puntatore al frame precedente, ma il frame precedente è sullo stack.
E la distanza tra il nostro frame pointer e il frame pointer salvato è sempre la stessa nello stesso programma seguendo lo stesso path di esecuzione.

Quindi, esattamente come abbiamo leakato il canary, possiamo leakare il frame pointer salvato.

Quindi, anche se lo stack è a un indirizzo random, possiamo leakare quell’indirizzo.
E avendo un puntatore allo stack, possiamo calcolare tutti gli altri puntatori allo stack aggiungendo o sottraendo alcuni valori fissi.

Quindi, se riusciamo a leakare quel valore, allora possiamo semplicemente calcolare la distanza tra questo valore e il return address salvato, e quindi sappiamo…
Voglio dire, possiamo sostituire questo return address salvato con questo indirizzo e possiamo mettere lo shellcode qui, esattamente come abbiamo fatto nell’esempio.


### Non-exectuable Stack 

qualsiasi area dati non è eseguibile quando NX è abilitato, Solo il codice è eseguibile.

Attacco piu semplice:

- se il programma ha qualche funzione che vuoi chiamare, la funzione fa parte del programma, quindi sta in una parte della memoria che è eseguibile, perché il programma potrebbe eseguire quella funzione.


return-to-libc attack:

- ogni programma ha la libc in memoria (linkato a libc)
- puoi eseguire parti della libc.
- ddentro libc c’è una funzione chiamata system che esegue un comando per te
- Se riesci a chiamare system passandogli la stringa /bin/sh, apre una shell.

Nel caso di un **NON-PIE** le entry PLT sono sempre a indirizzi fissi, anche quando **ASLR è attivo**.


E un altro trucco è usare il cosiddetto **return-oriented programming (ROP)**.
E l’idea è che, se puoi trovare pezzi di codice che fanno qualcosa, e puoi chiamare diversi pezzi uno dopo l’altro, puoi ottenere un comportamento più complesso concatenando questi piccoli elementi.

Nota: `mprotect` è una system call, incapsulata in una funzione esportata da `libc`, che ti permette di cambiare le protezioni di memoria su una pagina.

- se riesci a chiamare mprotect e rendere alcune pagine eseguibili, allora, ovviamente, puoi eseguire quelle pagine.

Il ROP è una tecnica di exploit che permette a un attaccante di eseguire codice arbitrario senza iniettare nuovo codice, ma riutilizzando frammenti di codice già presenti nel programma o nelle librerie.
Questi frammenti si chiamano gadget.

Un gadget è:

- un piccolo pezzo di codice già presente nel binario
- che termina con un’istruzione ret
- che esegue tipicamente una o poche istruzioni utili (come pop eax, mov [reg], reg, add esp, XX, ecc.)

#### tbg_files/the_best_game/bg1_docker/best_game1

```sh
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    Stripped:   No
```

- adesso NX per lo stack abilitato 
- No PIE quindi gli indirizzi all’interno del programma sono sempre gli stessi a ogni esecuzione.
- char no_more_spawn_shell_ahahah[] = "/bin/sh";  

Possiamo chiamare la funzione system

 - Verifichaimo che sia presente nella PLT:
 - `objdump -d ./best_game1| grep system`

Quindi possiamo sovrascrivere il return address con l’indirizzo di system nella PLT, che è un indirizzo fisso perché il binario non è PI, non è position independent.
Poi possiamo semplicemente inviare l’indirizzo della variabile globale come suo primo argomento.

Perchè aggiungiamo `fake` dopo il `return address`?

- Vedere **CallingConventionWithExploit.md**

#### tbg_files/the_best_game/bg2_docker/best_game2

```sh
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No

```

Stessa situzioane ma il binario è a 64 bit


In un binario a 64 bit cambia la calling convention: il primo argomento non viene passato sullo stack ma nel registro `RDI`, che l’attaccante non controlla direttamente. Per impostarlo si usano gadget ROP, in particolare uno del tipo `pop rdi ; ret`:

1. Riempire lo stack fino al return address.
2. Mettere come “finto” return address l’indirizzo del gadget `pop rdi ; ret`.
3. Subito dopo, sullo stack, mettere l’indirizzo della stringa `/bin/sh` (che finirà in `RDI` quando il gadget verrà eseguito).
4. Poi mettere l’indirizzo di `system`.

Serve anche rispettare l’allineamento dello stack a 16 byte richiesto dalla calling convention a 64 bit. Se disallineato, si può inserire un `ret` extra nella catena ROP (cioè l’indirizzo di un’istruzione `ret`) per “consumare” uno slot da 8 byte e riallineare. L’allineamento può differire tra macchina locale e server remoto, quindi a volte è necessario aggiungere o togliere un `ret` nella catena per evitare crash lato remoto.


```sh
ropper --file ./best_game2 --search 'pop rdi'
0x0000000000400913: pop rdi; ret; 
```

### PIE

Quello che invece funziona, ed è ciò che di solito si fa, è un attacco in due stadi (two-stage attack).

1. Nel primo stadio fai leak di un indirizzo di libc o del programma (qualunque cosa ti interessi).
2. Nel secondo stadio, una volta che hai questo indirizzo, puoi chiamare quello che vuoi dentro libc.

Per esempio, se trovi l’indirizzo di libc, puoi chiamare system passando /bin/sh, come abbiamo già visto.



#### tbg_files/the_best_game/bg2_pie_docker/best_game2/best_game2_pie

```sh
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
```

**Attenzione**
quando PI è abilitato:

- lo spazio di indirizzamento è randomizzato a a runtime (no compiletime)
- Anche in locale, se lo esegui due volte, ottieni due indirizzi diversi.
- In GDB potresti ottenere sempre lo stesso indirizzo, perché credo che per default GDB disabiliti l’ASLR

 **prima soluzione**

Idea: trovare la *base di libc* per poi chiamare `system("/bin/sh")`.

1. `__libc_start_main` viene sempre chiamata quando parte un programma → il suo indirizzo finisce sullo stack.
2. Se otteniamo un leak di uno qualsiasi degli indirizzi di libc, ad esempio proprio quello di `__libc_start_main`, allora:

   * sottraiamo l’**offset noto** di `__libc_start_main`,
   * otteniamo la **base address di libc**.
  
3. Con la base address possiamo calcolare:

   * l’indirizzo di `system`,
   * l’indirizzo della stringa `/bin/sh`,
   * o qualunque altra funzione utile.

4. A quel punto basta costruire una **ROP chain** e chiamare:

```c
system("/bin/sh")
```


# **seconda soluzione**

Idea: non serve la libc → basta trovare la *base del programma PIE*.

1. Si sfrutta il fatto che il programma PIÈ **ristampa il buffer overflow**, permettendo di **leakare il return address di main**.
   1. lo leakiamo a runtime con pwntool andando a leggere i byte presenti nello stack nello slot IP

2. Quel return address ha un **offset noto** dentro il binario (es. `0x9f2`).

```sh
$ objdump -d best_game2_pie | grep "<quiz>"
 9ed:   e8 b8 fe ff ff          call   8aa <quiz>
```

Esploriamo in quale offset andremo una volta che quiz ritorna

```sh
$ objdump -d best_game2_pie --start-address=0x9ed:

$ 00000000000009ed <main+0x63>:
 9ed:   e8 b8 fe ff ff          call   8aa <quiz>
 9f2:   b8 00 00 00 00          mov    $0x0,%eax
```

3. Base del programma = ```leak - offset_return_main```

4. Una volta nota la **base address del binario**, possiamo ricavare gli indirizzi di:

   * gadget ROP (`pop rdi`, `ret`),
   * la stringa interna al programma,
   * la funzione `system@plt`.

5. Costruiamo una ROP chain: come eserczio precedente


Attenzione: Quando un programma PIE viene caricato in memoria, il kernel non lo mette a un indirizzo qualsiasi:

- Loggare sempre il base adress
- il kernel lo allinea all’inizio di una pagina di memoria modulo 0000
- se non finiscono con 000 → qualcosa è sbagliato


**Note pratiche — libc locale vs remota e versioni allineate**
Fino a qui avevamo le syscall nella PLT quindi non adavamo a interrogare la libc
Assumiamo che dobbiamo andare e recupereare gli offset nella libc 

Ogni versione di libc ha offset diversi per le sue funzioni.
Se la tua versione locale e quella del server sono identiche, l'exploit funziona direttamente.
Se differiscono, devi adattare gli offset.

Se non conosci la versione di libc sul server, puoi scoprirla facendo leak di indirizzi e usando database online.
Tre o quattro leak (ad esempio di printf, read, altre funzioni) permettono di identificare univocamente la versione di libc.
Una volta identificata, puoi scaricare esattamente quella libc e trovare tutti gli offset necessari.

### Strategie di allineamento

**Approccio 1: due versioni dello script**

- Una per la tua macchina con i tuoi offset
- Una per il server con gli offset remoti
- Svantaggio: devi mantenere due set di offset

**Approccio 2: usare la stessa libc in locale**
Usa `patchelf` per forzare l'eseguibile a caricare una specifica versione di libc.
```sh
patchelf --set-interpreter /path/to/libc/ld.so --set-rpath /path/to/libc ./best_game3
```

Questo permette di debuggare localmente il comportamento identico al server.
Verifica con GDB che libc e il loader vengano caricati dalla directory corretta, non da `/usr/lib/`.

**Attenzione a LD_PRELOAD**

Non usare `LD_PRELOAD` con versioni diverse di linker e libc: il dynamic linker e libc vanno a braccetto, e il risultato non è deterministico.
L'unico modo sicuro è usare lo stesso linker corrispondente alla stessa versione di libc.

#### tbg_files/the_best_game/best_game3/best_game3-libc-2.27

```sh
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b'$ORIGIN/'
    Stripped:   No
```

- Come prima ma non abbiamo system nella PLT
- Dovremo calcolarci l'offset in libc tramite una syscall presente nella PLT
- Ogni server ha la propria libc con ofset diversi ... vediamo come affrontare la cosa 


Exploit con **OneGadget**

Per il leak, però, non stai sovrascrivendo solo il return address di quiz. Continuando ad andare avanti nello stack, arrivi anche al frame precedente, cioè quello di main, che a sua volta è stato chiamato da `__libc_start_main.`


#### tbg_files/the_best_game/best_game4/best_game4-libc-2.27

```sh
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x3fe000)
    RUNPATH:    b'$ORIGIN/'
    Stripped:   No
```

- libc è randomizzata: anche se il programma non è position independent, libc lo è.
- Questo significa che, anche se gli indirizzi dentro il programma sono fissi, libc viene caricata a un indirizzo diverso a ogni esecuzione.
- vorremmo è spawnare una shell, e non esiste, dentro il programma, una funzione che lo faccia.


- PROBLEMA: ma non c’è un loop che ci consenta di fare il leak degli indirizzi
- Quindi, se facciamo il leak di qualcosa, quel leak è inutile: quando eseguiamo di nuovo il programma, otteniamo indirizzi diversi.


Il trucco è creare noi un loop.

- Nel primo giro, facciamo il leak di un indirizzo di libc e poi ritorniamo a quiz.
- La volta successiva che quiz viene eseguita, sappiamo già l’indirizzo di libc.
- Possiamo allora fare un nuovo buffer overflow e, questa volta, saltare dentro libc e spawnare una shell.

Trucco PLT/GOT per leakare libc

Possiamo fare in modo che il programma stampi qualcosa chiamando, per esempio, putchar o printf o un’altra funzione di libc che stampa.
Per chiamare quella funzione, visto che ancora non conosciamo l’indirizzo di libc, dobbiamo passare per la PLT del programma, perché la PLT ha un indirizzo fisso.

- chiamiamo putchar nella PLT,
- e gli passiamo come primo argomento l’entry corrispondente nella GOT di putchar.

La GOT è una struttura dati dentro il nostro programma che contiene i puntatori alle reali implementazioni delle funzioni dentro libc.


Quindi chiamiamo putchar, passandogli come argomento il suo stesso puntatore in GOT.

Una volta che lo conosciamo l indirizzo di putchar, sottraiamo da quell’indirizzo l’offset di putchar per quella versione di libc e otteniamo la base a cui libc è stata caricata.

Il problema ora è che dobbiamo riavviare quiz. Quindi, dopo putchar, chiamiamo di nuovo quiz.

- In questo modo la funzione viene rieseguita e possiamo eseguire il secondo stadio dell’attacco.