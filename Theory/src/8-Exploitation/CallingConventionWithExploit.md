## Calling Convention and Exploitation Examples
 
Quando facciamo le exploit sovrascrivendo il ret con un indirizzo di una funzione, prima di aggingere i parametri, dobbiamo aggiungere un fake return address.

In una situzione nornale questo viene creato dal istruzione `CALL` del chiamante.
Se entri con RET, il chiamante NON ha eseguito CALL → quindi NON ha messo alcun return address.
Per la corretta gestione dello stack dobbiamo aggiungere un fake return address.

Esempio: 

Sono dentro la funzione `main`:

- prima di passare alla funzione quiz() la CALL di main()

  - Salava gli arogmenti di quiz()
  - Salva il IP di main() (IP corrente del main prima di saltare a quiz()) 

```c
int main() {
     quiz(arg1, arg2);
     somecode++;
}
```

| argomento = arg2        | <-- push arg2 (ultimo argomento)
| argomento = arg1        | <-- push arg1 (prima degli altri eventuali argomenti)
| ret                     | <-- push IP (il punto in main dove tornare dopo quiz) --> somecode++


Sono dentro `quiz()` adesso non voglio tornare a main() ma
voglio andare a `pippo()` conoscendo l indirizzo di `pippo()`.

Cosa faccio nello stack di quiz() prima di fare ret:

- Sovrascrivo il ret  con l’indirizzo di `pippo()`
  - In ret c'era l’indirizzo dove `quiz()` sarebbe dovuta tornare nel main. (somecode++)

- aggiungo un  `ret fittizio` che dovrebbe rappresentare l IP salvato dalla funzione `quiz()` prima di chiamare `pippo()` (come ha fatto  `main()` prima di chiamare  `quiz()`)
- aggiungo gli argomenti di `pippo()` (se ci sono)

----

Cosa fa RET e perche infatti lo usaimo come allineamento per pulire lo stack:
(https://textbook.cs161.org/memory-safety/x86.html)

ret:                  ; micro-operazioni semplificate in cui
                      ; ripulisci lo staack facendolo puntare all rip
    eip ← rip         ; * eip ora vale quel indirizzo che era salvato nello stack **
