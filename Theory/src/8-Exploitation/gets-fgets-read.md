1. gets(buf)
Nota Importante: Non usare mai gets. È stata rimossa dallo standard C perché è pericolosa (non controlla la dimensione del buffer, causando buffer overflow).

Comportamento con \n: Legge l'input fino a quando non trova una nuova riga, ma scarta il \n e non lo inserisce nel buffer.

Terminatore: Aggiunge automaticamente il carattere nullo \0 alla fine della stringa.

2. fgets(buf, 32, stdin)
Questa è la scelta standard e sicura per leggere stringhe.

Comportamento con \n: A differenza di gets, mantiene il carattere \n all'interno del buffer (se c'è spazio). Se digiti "Ciao" e premi invio, il buffer conterrà 'C','i','a','o','\n','\0'.

Terminatore: Aggiunge sempre il \0.

Gestione: Di solito dovrai rimuovere il \n manualmente se non ti serve (ad esempio sovrascrivendolo con un \0).

3. read(0, buf, 31)
Questa è una system call di basso livello (POSIX). Non è una funzione specifica per le stringhe, ma per i dati grezzi.

Comportamento con \n: Legge esattamente quello che l'utente digita. Se premi invio, il \n viene inserito nel buffer come un normale byte.

Terminatore: NON aggiunge il \0. read non sa nulla delle stringhe C. Se vuoi usare il buffer con funzioni come printf, devi aggiungere manualmente il terminatore: buf[n_letti] = '\0'.




Quando scrivi printf("... %s ...", name);, la funzione inizia a leggere l'indirizzo di memoria dove punta name e continua a stampare un carattere dopo l'altro finché non incontra lo zero binario (\0).