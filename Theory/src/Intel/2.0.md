# x86 Architecture

Registers vs Memory Cells

- **Speed**: Registers are significantly faster than memory cells as they are located within the CPU and do not require external communication.
- **Size**: Registers are smaller in number but can store more data per unit compared to individual memory addresses.
- **Quantity**: CPUs typically have a limited number of registers (e.g., 10-30), while modern computers have billions of memory addresses (gigabytes of memory).
- **Addressing**: 
    - Memory cells are addressed numerically (e.g., address 0, 1, 2, etc.).
    - Registers are addressed by names (e.g., A, B, C), which vary depending on the CPU architecture.


Registers are fast, limited in number, and named, while memory cells are slower, abundant, and numerically addressed.

- **MMU Role**: The Memory Management Unit acts as an intermediary between physical memory and processes. It translates virtual addresses used by processes into physical addresses.
- **Virtual Memory**: Processes operate in a virtual memory space, giving the illusion of having the entire memory available to themselves.
- **Abstraction**: The MMU, along with paging, enables this abstraction, ensuring processes remain isolated and unaware of the physical memory layout.


CPU Execution Cycle

The CPU operates in a repetitive cycle to execute instructions. This cycle consists of three main stages:

1. **Fetch**: The CPU reads the instruction pointed to by the instruction pointer. For example, if the instruction pointer holds the value 10, the CPU retrieves the instruction from memory address 10. The complexity arises from varying instruction lengths (e.g., 1 to 15 bytes in x86 architecture).

2. **Decode**: The CPU interprets the fetched instruction. For instance, the binary pattern `55` might represent the `push rbp` instruction, depending on the context.

3. **Execute**: The CPU performs the operation specified by the instruction. For example, if the instruction is an addition, it sums the specified operands.

This cycle repeats continuously throughout the CPU's operation.

In kernel mode, the CPU may handle interrupts. When an interrupt occurs, the CPU pauses its current task, executes the corresponding interrupt handler, and then resumes its normal operation. This ensures efficient handling of system events.


## Types of Registers and Structure

- **AX, BX, CX, DX**: These are general-purpose registers. Historically, the accumulator (AX) was used to store arithmetic operation results.
- **Extended Registers**: The "X" in AX, BX, etc., stands for "extended," indicating compatibility with earlier architectures.


- **AX (16-bit)**: Composed of two 8-bit registers:
    - **AL (Low)**: Represents the lower 8 bits.
    - **AH (High)**: Represents the upper 8 bits.


For example:

```c++
MOV AX, 0x1234    ; AX = 0001001000110100 (binario)
                  ; AH = 00010010 (0x12)
                  ; AL = 00110100 (0x34)

MOV AL, 0xFF      ; AL change only
                  ; Now AX = 0x12FF
                  ; AH remains 0x12, AL becomes 0xFF

MOV AH, 0xAB      ; AH change only
                  ; Now AX = 0xABFF
                  ; AH becomes 0xAB, AL remains 0xFF

```

Assembly instructions follow this general syntax:

`INSTRUCTION DESTINATION, SOURCE`

- The **destination** is the target operand.
- The **source** is the value or location being used.

For example:
- `MOV AH, 2`: Assigns the value 2 to the AH register.


1. **Registers**: e.g., AX, BX, CX, DX.
2. **Immediate Values**: Constants directly encoded in the instruction.
3. **Memory Addresses**: Accessed using square brackets in Intel syntax.

Examples:

- `MOV AX, 2`: Assigns the immediate value 2 to AX.
- `MOV AX, [2]`: Assigns to AX the value stored at memory address 2.

In the latter case, the number 2 represents an address, not a value.


The **SI** (Source Index) and **DI** (Destination Index) registers are 16-bit registers that cannot be divided like AX (into AH and AL). These registers are used as pointers, and some instructions work exclusively with them.

To read or write memory efficiently:

- **SI** is used as a source pointer.
- **DI** is used as a destination pointer.

Today, however, almost any register can be used to access memory.


Another important register is **SP** (Stack Pointer). The stack is a special area of memory used to "remember" information, such as where to resume execution after a function call.

### Example:

```c++
MOV AX, 2
CALL F
MOV AX, 3
...

F:  
MOV BX, 7  
...  
RET

```

- `CALL F`: Calls the function `F`. It is equivalent to a function call in C.
- After the function ends, execution resumes immediately after the `CALL`.


The SP points to a special area of memory used as a stack. The **Instruction Pointer (IP)**, on the other hand, points to the current instruction to be executed.

1. The `IP` points to the current instruction.
2. The CPU fetches the instruction from memory.
3. After the `fetch`, the `IP` automatically moves to the next instruction.
4. The CPU decodes and executes the instruction.

```asm
MOV AX, 2
```

- `MOV AX, 2`: Assigns the value `2` to the `AX` register.
- After the `fetch`, the `IP` is updated to the next instruction.

When a `CALL` is executed:
1. The address of the instruction following the `CALL` (let's call it `a`) is saved on the stack.
    - The stack is decremented (for historical reasons), and the value of the `IP` is written to the stack.
2. The `IP` is updated with the address of the called function.

Execution resumes from the called function, with the processor performing the `fetch-decode-execute` cycle for the function's instructions.

When a `RET` is executed:
1. The value saved on the stack (`a`) is popped and restored into the `IP`.
2. Execution resumes from where it was paused, immediately after the `CALL`.

> **Note**: Although logically the value in the stack is "erased," it physically remains in memory until it is overwritten.

## Memory Layout

What is needed to execute a program?

- **Code**: The instructions of the program.
- **Data**: Global and static variables.
- **Stack**: Used to keep track of function calls and local variables (LIFO).
- **Heap**: Used for dynamic memory allocation (e.g., `malloc` in C or `new` in Java/C++).

Stack and Heap Growth Directions

- The stack grows towards lower memory addresses (decrements).
- The heap grows towards higher memory addresses (increments).
- These two areas must never overlap.

With 64-bit addressing, it is theoretically possible to have the stack and heap grow in the same direction, separated by a vast address space. However, historically, the stack was designed to grow downwards, and this behavior persists today.

## Function Arguments and Return Values

A classic method (commonly used in 32-bit systems) involves:
- Pushing arguments onto the stack (`push`).
- Storing the return value in the accumulator (now EAX or RAX instead of AX).

### Example

Consider the function call `f(1, 2, 3)`:

```c++
PUSH 3
PUSH 2
PUSH 1
CALL F
ADD SP, 6 
```

Stack (downward growth):
+-----------------+
|       1         | ← First PUSH (last out)
+-----------------+
|       2         | ← Second PUSH (first out)
+-----------------+
|       3         | ← Third PUSH (last inserted by CALL)
+-----------------+
+-----------------+
| Indirizzo ret.  | ← Saved IP (g) by CALL
+-----------------+

Explanation:

1. **Stack Pointer (SP)**: Points to the last valid value in the stack.
2. **Instruction Pointer (IP)**: Points to the current instruction.

- `PUSH 3`: The stack pointer (SP) is decremented by 2 (on 16-bit systems), and the value `3` is written to the stack.
- `PUSH 2`: SP is decremented again, and `2` is written.
- `PUSH 1`: SP is decremented, and `1` is written.

At this point, the stack (from top to bottom) contains: `1, 2, 3`.

- `CALL F`: 
    - The current instruction pointer (IP), denoted as `g`, is saved onto the stack.
    - SP is decremented.
    - IP is updated to the address of the function `F`.

- `RET`:
    - Pops the value `g` from the stack.
    - Restores it to IP.
    - Execution resumes immediately after the `CALL`.

- `ADD SP, 6`: Removes the three arguments from the stack, restoring SP to its initial position.

## 8086 Specifics

The term **word** refers to the natural data size a processor operates on:

- For a 16-bit processor, a word is 16 bits.
- For a 32-bit processor, a word is 32 bits.
- For a 64-bit processor, a word is 64 bits.

Since the 8086 is a 16-bit processor, the convention of referring to 16 bits as a **word** has persisted. Today, we use the following terminology:

- **Word**: 16 bits
- **Double Word**: 32 bits
- **Quad Word**: 64 bits


x86 instructions have a **variable length** for the instruction, ranging from 1 byte to 15 bytes. This contrasts with architectures like ARM, where instruction lengths are typically fixed (e.g., 4 bytes). Variable-length instructions enable advanced techniques, such as code obfuscation.

Intel x86 is **little-endian** by default, meaning that in memory, the bytes appear in reverse order compared to their numerical value.

In this course, we will primarily focus on the **user mode** of x86. The main operational modes are:

1. **64-bit mode**: Used by modern processes on Windows and Linux.
2. **Compatibility mode**: Used for 32-bit processes, functioning similarly to the true 32-bit mode of older processors.

> Note: There is also a third compatibility mode for legacy systems, which we will not cover.


When using an address in user mode, the first transformation is **segmentation**.
Technically, each address passes first through the segment translation unit and then through paging.

In modern operating systems, however, (except for thread local storage), all selectors have a 0 offset and a '+infinity' limit, so segmentation does not alter the address.
In practice: the hardware for segmentation exists, but is not used.
The real virtualisation of memory occurs through **paging**.


### Intel vs. AT&T Syntax

x86 assembly has two main syntaxes:

1. **Intel Syntax**: More readable and used in this course.
2. **AT&T Syntax**: Used in some tools and articles.

Key Differences in AT&T Syntax:

- Operand Order: Source on the left, destination on the right.
- Register Prefix: Registers are prefixed with `%` (e.g., `%eax`).
- Immediate Value Prefix: Immediate values are prefixed with `$` (e.g., `$1`).
- Size Suffix: Instruction size is indicated by a suffix (`l` for 32-bit, `q` for 64-bit).
- Memory Addressing : The format differs between the two syntaxes.


| **Intel Code**            | **AT&T Code**                          |
|----------------------------|----------------------------------------|
| `mov eax, 1`              | `movl $1, %eax`                       |
| `mov ebx, 0FFh`           | `movl $0xff, %ebx`                    |
| `int 80h`                 | `int $0x80`                          |
| `mov ebx, eax`            | `movl %eax, %ebx`                    |
| `mov eax, [ecx]`          | `movl (%ecx), %eax`                  |
| `mov eax, [ebx+3]`        | `movl 3(%ebx), %eax`                 |
| `mov eax, [ebx+20h]`      | `movl 0x20(%ebx), %eax`              |
| `add eax, [ebx+ecx*2h]`   | `addl (%ebx, %ecx, 0x2), %eax`       |
| `lea eax, [ebx+ecx]`      | `leal (%ebx, %ecx), %eax`            |
| `sub eax, [ebx+ecx*4h-20h]` | `subl -0x20(%ebx, %ecx, 0x4), %eax` |