# x86 Architecture

Registers vs Memory Cells

- **Speed**: Registers are significantly faster than memory cells as they are located within the CPU and do not require external communication.
- **Size**: Registers are smaller in number but can store more data per unit compared to individual memory addresses.
- **Quantity**: CPUs typically have a limited number of registers (e.g., 10-30), while modern computers have billions of memory addresses (gigabytes of memory).
- **Addressing**: 
    - Memory cells are addressed numerically (e.g., address 0, 1, 2, etc.).
    - Registers are addressed by names (e.g., A, B, C), which vary depending on the CPU architecture.


Registers are fast, limited in number, and named, while memory cells are slower, abundant, and numerically addressed.

- **MMU Role**: The Memory Management Unit acts as an intermediary between physical memory and processes. It translates virtual addresses used by processes into physical addresses.
- **Virtual Memory**: Processes operate in a virtual memory space, giving the illusion of having the entire memory available to themselves.
- **Abstraction**: The MMU, along with paging, enables this abstraction, ensuring processes remain isolated and unaware of the physical memory layout.


CPU Execution Cycle

The CPU operates in a repetitive cycle to execute instructions. This cycle consists of three main stages:

1. **Fetch**: The CPU reads the instruction pointed to by the instruction pointer. For example, if the instruction pointer holds the value 10, the CPU retrieves the instruction from memory address 10. The complexity arises from varying instruction lengths (e.g., 1 to 15 bytes in x86 architecture).

2. **Decode**: The CPU interprets the fetched instruction. For instance, the binary pattern `55` might represent the `push rbp` instruction, depending on the context.

3. **Execute**: The CPU performs the operation specified by the instruction. For example, if the instruction is an addition, it sums the specified operands.

This cycle repeats continuously throughout the CPU's operation.

In kernel mode, the CPU may handle interrupts. When an interrupt occurs, the CPU pauses its current task, executes the corresponding interrupt handler, and then resumes its normal operation. This ensures efficient handling of system events.


## 8086 Specifics

The term **word** refers to the natural data size a processor operates on:

- For a 16-bit processor, a word is 16 bits.
- For a 32-bit processor, a word is 32 bits.
- For a 64-bit processor, a word is 64 bits.

Since the 8086 is a 16-bit processor, the convention of referring to 16 bits as a **word** has persisted. Today, we use the following terminology:

- **Byte**: 8 bits
- **Word**: 16 bits
- **Double Word**: 32 bits
- **Quad Word**: 64 bits


x86 instructions have a **variable length** for the instruction, ranging from 1 byte to 15 bytes. This contrasts with architectures like ARM, where instruction lengths are typically fixed (e.g., 4 bytes). Variable-length instructions enable advanced techniques, such as code obfuscation.

Intel x86 is **little-endian** by default, meaning that in memory, the bytes appear in reverse order compared to their numerical value.
x86 is a little-endian system. This means that when storing a word in memory, the least significant byte is stored at the lowest address, and the most significant byte is stored at the highest address. For example, here we are storing the word `0x44332211` in memory:

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/littleendian.png}
\end{center}


In this course, we will primarily focus on the **user mode** of x86. The main operational modes are:

1. **64-bit mode**: Used by modern processes on Windows and Linux.
2. **Compatibility mode**: Used for 32-bit processes, functioning similarly to the true 32-bit mode of older processors.

> Note: There is also a third compatibility mode for legacy systems, which we will not cover.


When using an address in user mode, the first transformation is **segmentation**.
Technically, each address passes first through the segment translation unit and then through paging.

In modern operating systems, however, (except for thread local storage), all selectors have a 0 offset and a '+infinity' limit, so segmentation does not alter the address.
In practice: the hardware for segmentation exists, but is not used.
The real virtualisation of memory occurs through **paging**.


### Intel vs. AT&T Syntax

x86 assembly has two main syntaxes:

1. **Intel Syntax**: More readable and used in this course.
2. **AT&T Syntax**: Used in some tools and articles.

Key Differences in AT&T Syntax:

- Operand Order: Source on the left, destination on the right.
- Register Prefix: Registers are prefixed with `%` (e.g., `%eax`).
- Immediate Value Prefix: Immediate values are prefixed with `$` (e.g., `$1`).
- Size Suffix: Instruction size is indicated by a suffix (`l` for 32-bit, `q` for 64-bit).
- Memory Addressing : The format differs between the two syntaxes.


| **Intel Code**            | **AT&T Code** (destination on the right)                        |
|----------------------------|----------------------------------------|
| `mov eax, 1`              | `movl $1, %eax`                       |
| `mov ebx, 0FFh`           | `movl $0xff, %ebx`                    |
| `int 80h`                 | `int $0x80`                          |
| `mov ebx, eax`            | `movl %eax, %ebx`                    |
| `mov eax, [ecx]`          | `movl (%ecx), %eax`                  |
| `mov eax, [ebx+3]`        | `movl 3(%ebx), %eax`                 |
| `mov eax, [ebx+20h]`      | `movl 0x20(%ebx), %eax`              |
| `add eax, [ebx+ecx*2h]`   | `addl (%ebx, %ecx, 0x2), %eax`       |
| `lea eax, [ebx+ecx]`      | `leal (%ebx, %ecx), %eax`            |
| `sub eax, [ebx+ecx*4h-20h]` | `subl -0x20(%ebx, %ecx, 0x4), %eax` |


## Types of Registers and Structure

Note: Since the values in these three registers are usually addresses, sometimes we will say that a register points somewhere in memory.

- **AX, BX, CX, DX**: These are general-purpose registers. Historically, the accumulator (AX) was used to store arithmetic operation results.
- **Extended Registers**: The "X" in AX, BX, etc., stands for "extended," indicating compatibility with earlier architectures.


- **AX (16-bit)**: Composed of two 8-bit registers:
    - **AL (Low)**: Represents the lower 8 bits.
    - **AH (High)**: Represents the upper 8 bits.


For example:

```c++
MOV AX, 0x1234    ; AX = 0001001000110100 (binario)
                  ; AH = 00010010 (0x12)
                  ; AL = 00110100 (0x34)

MOV AL, 0xFF      ; AL change only
                  ; Now AX = 0x12FF
                  ; AH remains 0x12, AL becomes 0xFF

MOV AH, 0xAB      ; AH change only
                  ; Now AX = 0xABFF
                  ; AH becomes 0xAB, AL remains 0xFF

```

Assembly instructions follow this general syntax:

`INSTRUCTION DESTINATION, SOURCE`

- The **destination** is the target operand.
- The **source** is the value or location being used.

For example:
- `MOV AH, 2`: Assigns the value 2 to the AH register.


1. **Registers**: e.g., AX, BX, CX, DX.
2. **Immediate Values**: Constants directly encoded in the instruction.
3. **Memory Addresses**: Accessed using square brackets in Intel syntax.

Examples:

- `MOV AX, 2`: Assigns the immediate value 2 to AX.
- `MOV AX, [2]`: Assigns to AX the value stored at memory address 2.

In the latter case, the number 2 represents an address, not a value.


The **SI** (Source Index) and **DI** (Destination Index) registers are 16-bit registers that cannot be divided like AX (into AH and AL). These registers are used as pointers, and some instructions work exclusively with them.

To read or write memory efficiently:

- **SI** is used as a source pointer.
- **DI** is used as a destination pointer.

Today, however, almost any register can be used to access memory.

Another important register is

- **IP** (Instruction Pointer). This register points to the current instruction being executed.
- **SP** (Stack Pointer). The stack is a special area of memory used to "remember" information, such as where to resume execution after a function call.
   It stores the address of the top of the stack.
- **BP** (Base Pointer). This register is used to reference function parameters and local variables within the stack.
  - It stores the address of the top of the current stack frame.



###  Pushing and popping

Sometimes we want to remember a value by saving it on the stack. There are two steps to storing a value on the stack. First, we have to allocate additional space on the stack by decrementing esp. Then, we store the value in the newly allocated space. The x86 push instruction does both of these steps to store a value to the stack.

\begin{center}
\includegraphics[width=0.6 \linewidth]{./media/push.png}
\end{center}

We may also want to remove values from the stack. The x86 pop instruction increments esp to remove the next value on the stack. It also takes the value that was just popped and copies the value into a register AX.

Note that when we pop a value off the stack, the value is erased from memory. However, we increment esp so that the popped value is now below esp. The esp register points to the bottom of the stack, so the popped value below esp is now in undefined memory.

\begin{center}
\includegraphics[width=0.6 \linewidth]{./media/pop.png}
\end{center}

## Memory Layout

What is needed to execute a program?

- **Code**: The instructions of the program.
- **Data**: Global and static variables.
- **Stack**: Used to keep track of function calls and local variables (LIFO).
- **Heap**: Used for dynamic memory allocation (e.g., `malloc` in C or `new` in Java/C++).

Stack and Heap Growth Directions

- The stack grows towards lower memory addresses (decrements).
- The heap grows towards higher memory addresses (increments).
- These two areas must never overlap.

With 64-bit addressing, it is theoretically possible to have the stack and heap grow in the same direction, separated by a vast address space. However, historically, the stack was designed to grow downwards, and this behavior persists today.

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/stack.png}
\end{center}

At runtime, the operating system gives the program an address space to store any state necessary for program execution. You can think of the address space as a large, contiguous chunk of memory. **Each byte of memory has a unique address.**

The **size of the address** space depends on your operating system and CPU architecture. In a 32-bit system, memory addresses are 32 bits long, which means the address space has 2^32 bytes of memory. In a 64-bit system, memory addresses are 64 bits long.

## Calling Convention

A classic method (commonly used in 32-bit systems) involves:

- Pushing arguments onto the stack (`push`).
- Storing the return value in the accumulator (now EAX or RAX instead of AX).


The last argument is pushed first, and the first argument is pushed last.

- This ensures that when the function starts, the first argument is always at a fixed distance from the return address on the stack.
- This is crucial for functions with a variable number of arguments (e.g., `printf("...", a, b, c, ...)`). 
- If the arguments were placed in the opposite order, the function would not know where the first parameter begins without additional information.

### Example (32-bit)

Consider the function caller `main` and the corresponding function callee `foo`:

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/cc1.png}
\end{center}

```c++
int main(void) {
    foo(1, 2);
}

void foo(int a, int b) {
    int bar[4];
}
```


```s
main:

    # Step 1. Push arguments on the stack in reverse order
    push $2
    push $1

    # Steps 2-3. Save old eip (rip) on the stack and change eip
    call foo

    # Execution changes to foo now. After returning from foo:

    # Step 11: Remove arguments from stack
    add $8, %esp

foo:

    # Step 4. Push old ebp (sfp) on the stack
    push %ebp

    # Step 5. Move ebp down to esp
    mov %esp, %ebp

    # Step 6. Move esp down
    sub $16, %esp

    # Step 7. Execute the function (omitted here)

    # Step 8. Move esp
    mov %ebp, %esp

    # Step 9. Restore old ebp (sfp)
    pop %ebp

    # Step 10. Restore old eip (rip)
    pop %eip
```

The number 16 is determined by the compiler depending on the function being called. In this case, the compiler decides 16 bytes are required to fit the local variable and any other data needed for the function to execute.

NOTE: 

- Steps 8-9 are often combined into a single instruction: **`leave`**, which performs both operations.
- The instruction in step 10 is sometimes abbreviated as the **`ret`** instruction.
- Steps 4-6 are sometimes called the function **prologue**, since they must appear at the start of the assembly code of any C function. 
- Similarly, steps 8-10 are sometimes called the function **epilogue**.
- Starting with EBP, with positive offsets we can find the arguments, and with negative offsets we can find the local variables.

see: [Memory Safety](https://textbook.cs161.org/memory-safety/x86.html#28-x86-function-calls)


### Conventions (32-bit)

1. Optional Use of EBP as Frame Pointer  
    The EBP (Base Pointer) register is used to point to the start of the current stack frame, making it easier to access function parameters and local variables. However, in many modern compilers, the use of EBP as a frame pointer is optional. When not used, the compiler accesses local variables and parameters directly via the ESP (Stack Pointer), freeing up the EBP register for other purposes.

2. Caller-Saved Registers  
    Certain registers must be preserved by the caller during a function call. These include:  
    - EBP: Used as the frame pointer.  
    - EBX: Typically used for persistent data.  
    - EDI and ESI: Commonly used for data copying or manipulation.  
    - ESP: Must always point to the top of the stack.  
    If a function modifies any of these registers, it must save their values at the start and restore them before returning control to the caller.

3. Function Return Values  
    - Integral values (e.g., `int`, `char`) or pointers (e.g., `int*`) are returned in the EAX register.  
    - For 64-bit return values (e.g., `long long`), the EDX register is also used to store the most significant bits.


### Convention (64-bit)

1. The first six arguments are passed through registers in the following order:
   
- `RDI`
- `RSI`
- `RDX`
- `RCX`
- `R8`
- `R9`

If there are more than six arguments, the stack is used for the remaining ones.

2. The return value of a function is stored in:
   
- `RAX` (for most types, such as `int`, pointers, etc.)
- If the return value is larger (e.g., a `struct`), `RDX` may also be used as a secondary register to return data.

3. Certain registers must be preserved either by the caller or the callee to ensure that important values are not accidentally overwritten.

 - `RBP` (base pointer)
 - `RBX`
 - `R12`, `R13`, `R14`, `R15`
 - `RSP` (stack pointer)

- **Notes:**
    - In 32-bit systems, `EDI` and `ESI` also had to be preserved.
    - In 64-bit systems, `RDI` and `RSI` can be freely modified.


### Program Entry

When a compiled C program starts, the entry point is not `main`. Instead, it begins with library code responsible for initialization, which then calls `main`.

```c
int main(int argc, char** argv, char** envp)
```

1. Number of Command-Line Arguments (`argc`)
2. Pointers to Command-Line Arguments (`argv`)
3. A Null Pointer
4. Pointer to the Environment (`envp`)
5. Another Null Pointer
6. ELF (Executable and Linkable Format) Data
7. Environment Strings, Program Name, etc.

> Note: This stack layout does not adhere to the calling convention typically used for functions.


## System Calls

System calls are invoked by a process to request the operating system to perform specific tasks.

When programming in C or C++, system calls appear as regular library function calls. However, these library functions are wrappers that contain special instructions (which vary depending on the processor) to invoke the actual system call.


There is no portable way in C to directly make a system call.


During a system call, a context switch occurs from user mode to kernel mode. This switch is significantly slower than a regular function call.

A wrapper function performs the following steps:

1. Uses assembly code to:
    - Place the arguments into CPU registers.
    - Place the syscall number into a register. [Syscall Reference](https://syscalls.w3challs.com/)  
    - Trigger a "trap" into the kernel.
2. The kernel executes the system call handler, which:
    - Validates the syscall number and arguments.  
    - Calls the actual routine corresponding to the system call.
    - Places the result in a register.
    - Switches back to user mode using a special instruction.
3. The wrapper function:
    - Checks the result.
    - On error, sets `errno` and returns an error code (typically `-1`).
    - Otherwise, returns the result.

### 32-bit 

In Linux 32-bit assembly programming, system calls are handled as follows:

1. System Call Number: Place the system call number in the `EAX` register.
2. Parameters: The six parameters are passed in the following registers, in order:
    - `EBX`
    - `ECX`
    - `EDX`
    - `ESI`
    - `EDI`
    - `EBP`
3. Additional Arguments: If more than six arguments are needed, use structures or pointers.
4. Return Value: The return value of the system call is stored in the `EAX` register.
5. Register Preservation: All registers are preserved during the system call.

### Example

The following example demonstrates how to use system calls to write "Hello World" to the standard output and then exit:

```c++
section .text
global _start

_start:
     mov eax, 4          ; System call number for write
     mov ebx, 1          ; File descriptor (stdout)
     mov ecx, msg        ; Address of the message string
     mov edx, msglen     ; Length of the message
     int 0x80            ; Make the system call

     mov eax, 1          ; System call number for exit
     mov ebx, 0          ; Exit status code
     int 0x80            ; Make the system call

section .data
msg: db "Hello World", 10  ; Message string with newline
msglen equ $-msg           ; Calculate the length of the message
```
> Note: If the `exit` system call is not invoked, the processor will continue executing the subsequent code, which may lead to a segmentation fault.

### 64-bit

In Linux 64-bit assembly programming, system calls are handled as follows:

1. System Call Number: Place the system call number in the `RAX` register.
2. Parameters: The six parameters are passed in the following registers, in order:
   
    - `RDI`
    - `RSI`
    - `RDX`
    - `R10`
    - `R8`
    - `R9`
  
3. Additional Arguments: If more than six arguments are needed, use structures or pointers.
4. Return Value: The return value of the system call is stored in the `RAX` register.
5. Register Preservation: All registers are preserved during the system call, except for `RAX` and `R11`.
   - `RCX` and `R11` are implicitly used by the syscall instruction for saving `RIP` and `RFLAGS`.

### Example

 ```c++
    section .text
    global main
    main:
        mov rax, 1          ; use the write syscall
        mov rdi, 1          ; write to stdout
        mov rsi, msg        ; use string "Hello World"
        mov rdx, msglen     ; write 12 characters
        syscall             ; make syscall
        mov rax, 60         ; use the exit syscall
        mov rdi, 0          ; error code 0
        syscall             ; make syscall

    section .data
    msg: db "Hello World", 10
    msglen equ $-msg
```