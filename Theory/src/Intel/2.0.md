# x86 Architecture

Registers vs Memory Cells

- **Speed**: Registers are significantly faster than memory cells as they are located within the CPU and do not require external communication.
- **Size**: Registers are smaller in number but can store more data per unit compared to individual memory addresses.
- **Quantity**: CPUs typically have a limited number of registers (e.g., 10-30), while modern computers have billions of memory addresses (gigabytes of memory).
- **Addressing**: 
    - Memory cells are addressed numerically (e.g., address 0, 1, 2, etc.).
    - Registers are addressed by names (e.g., A, B, C), which vary depending on the CPU architecture.


Registers are fast, limited in number, and named, while memory cells are slower, abundant, and numerically addressed.

- **MMU Role**: The Memory Management Unit acts as an intermediary between physical memory and processes. It translates virtual addresses used by processes into physical addresses.
- **Virtual Memory**: Processes operate in a virtual memory space, giving the illusion of having the entire memory available to themselves.
- **Abstraction**: The MMU, along with paging, enables this abstraction, ensuring processes remain isolated and unaware of the physical memory layout.


CPU Execution Cycle

The CPU operates in a repetitive cycle to execute instructions. This cycle consists of three main stages:

1. **Fetch**: The CPU reads the instruction pointed to by the instruction pointer. For example, if the instruction pointer holds the value 10, the CPU retrieves the instruction from memory address 10. The complexity arises from varying instruction lengths (e.g., 1 to 15 bytes in x86 architecture).

2. **Decode**: The CPU interprets the fetched instruction. For instance, the binary pattern `55` might represent the `push rbp` instruction, depending on the context.

3. **Execute**: The CPU performs the operation specified by the instruction. For example, if the instruction is an addition, it sums the specified operands.

This cycle repeats continuously throughout the CPU's operation.

In kernel mode, the CPU may handle interrupts. When an interrupt occurs, the CPU pauses its current task, executes the corresponding interrupt handler, and then resumes its normal operation. This ensures efficient handling of system events.


## 8086 Specifics

The term **word** refers to the natural data size a processor operates on:

- For a 16-bit processor, a word is 16 bits.
- For a 32-bit processor, a word is 32 bits.
- For a 64-bit processor, a word is 64 bits.

Since the 8086 is a 16-bit processor, the convention of referring to 16 bits as a **word** has persisted. Today, we use the following terminology:

- **Byte**: 8 bits
- **Word**: 16 bits
- **Double Word**: 32 bits
- **Quad Word**: 64 bits


x86 instructions have a **variable length** for the instruction, ranging from 1 byte to 15 bytes. This contrasts with architectures like ARM, where instruction lengths are typically fixed (e.g., 4 bytes). Variable-length instructions enable advanced techniques, such as code obfuscation.

Intel x86 is **little-endian** by default, meaning that in memory, the bytes appear in reverse order compared to their numerical value.
x86 is a little-endian system. This means that when storing a word in memory, the least significant byte is stored at the lowest address, and the most significant byte is stored at the highest address. For example, here we are storing the word `0x44332211` in memory:

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/littleendian.png}
\end{center}


In this course, we will primarily focus on the **user mode** of x86. The main operational modes are:

1. **64-bit mode**: Used by modern processes on Windows and Linux.
2. **Compatibility mode**: Used for 32-bit processes, functioning similarly to the true 32-bit mode of older processors.

> Note: There is also a third compatibility mode for legacy systems, which we will not cover.


When using an address in user mode, the first transformation is **segmentation**.
Technically, each address passes first through the segment translation unit and then through paging.

In modern operating systems, however, (except for thread local storage), all selectors have a 0 offset and a '+infinity' limit, so segmentation does not alter the address.
In practice: the hardware for segmentation exists, but is not used.
The real virtualisation of memory occurs through **paging**.


### Intel vs. AT&T Syntax

x86 assembly has two main syntaxes:

1. **Intel Syntax**: More readable and used in this course.
2. **AT&T Syntax**: Used in some tools and articles.

Key Differences in AT&T Syntax:

- Operand Order: Source on the left, destination on the right.
- Register Prefix: Registers are prefixed with `%` (e.g., `%eax`).
- Immediate Value Prefix: Immediate values are prefixed with `$` (e.g., `$1`).
- Size Suffix: Instruction size is indicated by a suffix (`l` for 32-bit, `q` for 64-bit).
- Memory Addressing : The format differs between the two syntaxes.


| **Intel Code**            | **AT&T Code** (destination on the right)                        |
|----------------------------|----------------------------------------|
| `mov eax, 1`              | `movl $1, %eax`                       |
| `mov ebx, 0FFh`           | `movl $0xff, %ebx`                    |
| `int 80h`                 | `int $0x80`                          |
| `mov ebx, eax`            | `movl %eax, %ebx`                    |
| `mov eax, [ecx]`          | `movl (%ecx), %eax`                  |
| `mov eax, [ebx+3]`        | `movl 3(%ebx), %eax`                 |
| `mov eax, [ebx+20h]`      | `movl 0x20(%ebx), %eax`              |
| `add eax, [ebx+ecx*2h]`   | `addl (%ebx, %ecx, 0x2), %eax`       |
| `lea eax, [ebx+ecx]`      | `leal (%ebx, %ecx), %eax`            |
| `sub eax, [ebx+ecx*4h-20h]` | `subl -0x20(%ebx, %ecx, 0x4), %eax` |


## Types of Registers and Structure

Note: Since the values in these three registers are usually addresses, sometimes we will say that a register points somewhere in memory.

- **AX, BX, CX, DX**: These are general-purpose registers. Historically, the accumulator (AX) was used to store arithmetic operation results.
- **Extended Registers**: The "X" in AX, BX, etc., stands for "extended," indicating compatibility with earlier architectures.


- **AX (16-bit)**: Composed of two 8-bit registers:
    - **AL (Low)**: Represents the lower 8 bits.
    - **AH (High)**: Represents the upper 8 bits.


For example:

```c++
MOV AX, 0x1234    ; AX = 0001001000110100 (binario)
                  ; AH = 00010010 (0x12)
                  ; AL = 00110100 (0x34)

MOV AL, 0xFF      ; AL change only
                  ; Now AX = 0x12FF
                  ; AH remains 0x12, AL becomes 0xFF

MOV AH, 0xAB      ; AH change only
                  ; Now AX = 0xABFF
                  ; AH becomes 0xAB, AL remains 0xFF

```

Assembly instructions follow this general syntax:

`INSTRUCTION DESTINATION, SOURCE`

- The **destination** is the target operand.
- The **source** is the value or location being used.

For example:
- `MOV AH, 2`: Assigns the value 2 to the AH register.


1. **Registers**: e.g., AX, BX, CX, DX.
2. **Immediate Values**: Constants directly encoded in the instruction.
3. **Memory Addresses**: Accessed using square brackets in Intel syntax.

Examples:

- `MOV AX, 2`: Assigns the immediate value 2 to AX.
- `MOV AX, [2]`: Assigns to AX the value stored at memory address 2.

In the latter case, the number 2 represents an address, not a value.


The **SI** (Source Index) and **DI** (Destination Index) registers are 16-bit registers that cannot be divided like AX (into AH and AL). These registers are used as pointers, and some instructions work exclusively with them.

To read or write memory efficiently:

- **SI** is used as a source pointer.
- **DI** is used as a destination pointer.

Today, however, almost any register can be used to access memory.

Another important register is

- **IP** (Instruction Pointer). This register points to the current instruction being executed.
- **SP** (Stack Pointer). The stack is a special area of memory used to "remember" information, such as where to resume execution after a function call.
   It stores the address of the top of the stack.
- **BP** (Base Pointer). This register is used to reference function parameters and local variables within the stack.
  - It stores the address of the top of the current stack frame.



###  Pushing and popping

Sometimes we want to remember a value by saving it on the stack. There are two steps to storing a value on the stack. First, we have to allocate additional space on the stack by decrementing esp. Then, we store the value in the newly allocated space. The x86 push instruction does both of these steps to store a value to the stack.

\begin{center}
\includegraphics[width=0.6 \linewidth]{./media/push.png}
\end{center}

We may also want to remove values from the stack. The x86 pop instruction increments esp to remove the next value on the stack. It also takes the value that was just popped and copies the value into a register.

Note that when we pop a value off the stack, the value is erased from memory. However, we increment esp so that the popped value is now below esp. The esp register points to the bottom of the stack, so the popped value below esp is now in undefined memory.

\begin{center}
\includegraphics[width=0.6 \linewidth]{./media/pop.png}
\end{center}

## Memory Layout

What is needed to execute a program?

- **Code**: The instructions of the program.
- **Data**: Global and static variables.
- **Stack**: Used to keep track of function calls and local variables (LIFO).
- **Heap**: Used for dynamic memory allocation (e.g., `malloc` in C or `new` in Java/C++).

Stack and Heap Growth Directions

- The stack grows towards lower memory addresses (decrements).
- The heap grows towards higher memory addresses (increments).
- These two areas must never overlap.

With 64-bit addressing, it is theoretically possible to have the stack and heap grow in the same direction, separated by a vast address space. However, historically, the stack was designed to grow downwards, and this behavior persists today.

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/stack.png}
\end{center}


At runtime, the operating system gives the program an address space to store any state necessary for program execution. You can think of the address space as a large, contiguous chunk of memory. **Each byte of memory has a unique address.**

The**size of the address** space depends on your operating system and CPU architecture. In a 32-bit system, memory addresses are 32 bits long, which means the address space has 2^32 bytes of memory. In a 64-bit system, memory addresses are 64 bits long. 

## Calling Convention

A classic method (commonly used in 32-bit systems) involves:

- Pushing arguments onto the stack (`push`).
- Storing the return value in the accumulator (now EAX or RAX instead of AX).


The last argument is pushed first, and the first argument is pushed last.

- This ensures that when the function starts, the first argument is always at a fixed distance from the return address on the stack.
- This is crucial for functions with a variable number of arguments (e.g., `printf("...", a, b, c, ...)`). 
- If the arguments were placed in the opposite order, the function would not know where the first parameter begins without additional information.


### Example

Consider the function caller `main` and the corresponding function callee `foo`:

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/cc1.png}
\end{center}

```c++
int main(void) {
    foo(1, 2);
}

void foo(int a, int b) {
    int bar[4];
}
```


```s
main:

    # Step 1. Push arguments on the stack in reverse order
    push $2
    push $1

    # Steps 2-3. Save old eip (rip) on the stack and change eip
    call foo

    # Execution changes to foo now. After returning from foo:

    # Step 11: Remove arguments from stack
    add $8, %esp

foo:

    # Step 4. Push old ebp (sfp) on the stack
    push %ebp

    # Step 5. Move ebp down to esp
    mov %esp, %ebp

    # Step 6. Move esp down
    sub $16, %esp

    # Step 7. Execute the function (omitted here)

    # Step 8. Move esp
    mov %ebp, %esp

    # Step 9. Restore old ebp (sfp)
    pop %ebp

    # Step 10. Restore old eip (rip)
    pop %eip
```
The number 16 is determined by the compiler depending on the function being called. In this case, the compiler decides 16 bytes are required to fit the local variable and any other data needed for the function to execute.

NOTE: 

- Steps 8-9 are often combined into a single instruction: **`leave`**, which performs both operations.
- The instruction in step 10 is sometimes abbreviated as the **`ret`** instruction.
- Steps 4-6 are sometimes called the function **prologue**, since they must appear at the start of the assembly code of any C function. 
- Similarly, steps 8-10 are sometimes called the function **epilogue**.


see: !(https://textbook.cs161.org/memory-safety/x86.html#28-x86-function-calls)
