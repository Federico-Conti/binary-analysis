Finora abbiamo discusso alcuni stack-based buffer overflows, e abbiamo già visto che un programma vulnerabile può permettere a un attaccante di modificare variabili locali, perché le variabili locali sono allocate sullo stack.
Se c’è un buffer overflow sullo stack, l’attaccante può cambiare il valore di alcune variabili, e questo a volte basta per cambiare il comportamento del programma.
Se puoi sostituire il return address, che è anch’esso salvato sullo stack, puoi controllare ciò che il programma esegue, e nei vecchi scenari discussi con la shellcoding, l’attaccante può iniettare nuovo codice e farlo eseguire al programma.

Questo però non è molto realistico nei sistemi operativi moderni: non puoi — con le tecniche discusse — iniettare nuovo codice in un processo e farlo eseguire, perché nelle OS moderne lo stack non è eseguibile.
Quindi anche se inietti codice, non puoi eseguirlo: otterresti una segmentation fault, perché le pagine dello stack sono marcate come non-executable.


## ASLR

L’ASLR è una mitigazione di sicurezza che randomizza l’indirizzo base dei programmi.
Significa che, se un programma supporta l’ASLR, ogni volta che lo esegui, il programma viene mappato a un indirizzo diverso nello process address space.

Tuttavia, il programma deve supportare l’ASLR.
Questo significa che, per essere caricato a un indirizzo casuale, il programma deve essere compilato come PIE (Position Independent Executable).
Position independent significa che il codice può essere eseguito a qualunque indirizzo, letteralmente.

Se il programma non è PIE, il sistema operativo non può randomizzare il suo indirizzo base.
Anche se l’ASLR è abilitato a livello di sistema operativo, se il programma è stato compilato senza position independent code, non può essere randomizzato.


Per vedere se un programma è PIE o non PIE puoi usare
- `file`
- `checksec --file /bin/ls` 


### superare la protezione di sicurezza ASLR

- PLT (Procedure Linkage Table): È una sezione di codice all'interno del programma principale. Quando il programma chiama una funzione esterna (come printf in libc), esegue prima un piccolo stub di codice che si trova nella PLT.
- GOT (Global Offset Table): È una tabella di puntatori a dati e funzioni esterne. Lo stub PLT di una funzione (es. printf) legge il puntatore alla sua vera implementazione che è memorizzato nella GOT.


la GOT è la chiave per "sconfiggere" l'ASLR di libc:

- Se l'eseguibile è PIE, anche la GOT viene randomizzata. L'attaccante deve quindi prima trovare un indirizzo leakato del programma per calcolare la base dell'eseguibile, e da lì calcolare l'indirizzo randomizzato della GOT (dato che l'offset tra la base e la GOT è fisso)
- GOT Contiene l'Indirizzo Reale: Poiché il programma deve chiamare la funzione printf in libc, la GOT deve contenere l'indirizzo reale e corrente della funzione printf all'interno della libc caricata casualmente.
- Leak del Puntatore: Se un attaccante sfrutta una vulnerabilità (ad esempio, una format string vulnerability o un buffer overflow con capacità di lettura) per leggere il contenuto della GOT per una funzione come printf, ottiene l'indirizzo esatto di printf per quella specifica esecuzione.
- Calcolo dell'Indirizzo Base (Base Address Calculation):Gli sviluppatori conoscono l'offset (la distanza fissa in byte) tra l'inizio di libc e la funzione printf.L'attaccante usa la seguente formula per trovare l'indirizzo base di libc per quell'esecuzione:
  `addr_libc_base = addr_printf - offset_printf` 

- Una volta che l'attaccante ha l'indirizzo base di libc, può aggiungere l'offset conosciuto di qualsiasi altra funzione di libc (es. system) per calcolare il suo indirizzo esatto. In questo modo, de-randomizza la libreria libc e può reindirizzare il flusso di esecuzione a funzioni pericolose, anche se l'ASLR è attivo.

Nota: Ovviamente questo indirizzo non sarà valido in altre esecuzioni


Con pwntools, avendo un ELF, puoi usare:


- `.plt.name` per ottenere l’indirizzo o l’offset della voce PLT
- `.got.name` per ottenere l’indirizzo o l’offset della voce GOT
- `elf.sym.name` per ottenere indirizzi/simboli

Se il programma è non-PIE, ottieni l’indirizzo reale.
Se è PIE, ottieni l’offset dal base address, che cambia sempre.




# format string vulnerability

## fmtsrt_files/example{32,64}

Quando printf viene chiamato con un solo argomento (name in questo caso), lo interpreta come stringa di formato, ovvero una sequenza che può contenere specificatori di formato (%x, %s, %n, ecc.). Se l'utente inserisce tali specificatori, printf tenterà di accedere alla memoria o scrivere in essa, anche se il programma non ha previsto ciò.

Exploit32: `%10$x` # richiesta di stampare 10 valori dalla pila.
Exploit64: `%8$x`

Se l'utente inserisce `%s`, printf cercherà di leggere un puntatore dalla pila e poi dereferenzierà quel puntatore per stampare la stringa a cui punta.
Ora, in questo caso il programma potrebbe crashare, perché se chiediamo di stampare una stringa puntata da qualcosa che non è un puntatore valido, il programma proverà a dereferenziare quel “puntatore” e otterrà una segmentation fault.


Exploit32: `%11$s`  # richiesta di stampare una stringa puntata dal valore in posizione 11 della pila.
Exploit64: `%9$s`


Il programma non ha un puntatore sullo stack che punti alla stringa `other_secret`.
Quindi, in condizioni normali, printf non può stamparla, perché:

- `printf("%x")` legge solo dallo stack.
- I puntatori alla .rodata (come `other_secret`) NON sono nello stack.
- Non possiamo far leggere a printf un indirizzo arbitrario che NON si trovi nello stack.

Quindi l’idea è:

Se il puntatore non è sullo stack ce lo mettiamo noi!

Qui che entra in gioco il buffer name.

- noi possiamo controllare completamente i 16 byte di name,

Il primo passo è capire a che slot si trova  `name[]` nello stack.

- Inviamo una stringa facilmente riconoscibile `aaaa` (in hex `61616161`) come name
- Usiamo `%x` per leggere vari valori dallo stack, finché non vediamo `61616161` stampato.
- Contiamo quanti `%x` abbiamo usato per arrivare a quel valore: quello è l’indice di name nello stack.

Esempio

```sh
What's your name? aaaaaaaa%6$x  -->  nota: ho un limite di 16 byte per stdinput
Hi, 61616161 --> stapa il sesto slot dello stack che contiene aaaa
```

Okey, quindi l'ultimo `a` è in posizione 7 nello stack.
Ora possiamo leggere il contenuto di name usando `%7$x`.

adesso vogliamo scrivere l'indirizzo di `other_secret` dentro `name`, in modo che printf possa leggerlo e dereferenziare quel puntatore.

Exploit32:
- Troviamo l’indirizzo di  `other_secret ` nell’ELF (basta leggere la symbol tabl con pwntools)
- Costruisce un payload:
- `%7$s 0x0804c040` --> occupa 6 byte e prima abbimao detto che con 6 byte siano allo slot 7 nello stack
- dove `0x0804c040` è l’indirizzo di `other_secret`
  
Quando printf legge questo payload:
- legge il puntatore `0x0804c040` da name (posizione 7 nello stack)
- dereferenzia quel puntatore
- stampa la stringa a cui punta `other_secret`


Nella versione 64 bit, invece, serve “riempire lo slot” con dati extra per allineare:

- uno slot = 8 byte
- quindi aggiungo 4 caratteri inutili, poi il pointer


Esempio visivo di Stacke di slot

```sh
Slot 7: |r|-|-|-|
Slot 6: |f|e|d|e|
```
