## Binary Reverse Engineering

Il primo approccio, quando si ha un file e non si sa nulla su di esso (per esempio lo si trova sul desktop e non si ricorda di averlo messo lì), è cercare di identificarlo. Come identificare un file? Il nome del file è un buon indicatore? No: è facilmente modificabile. Cosa si può fare allora?

Possiamo cercare di identificare il contenuto in modo più affidabile: ad esempio confrontando gli hash. Supponiamo di avere due file con nomi diversi ma stesso proprietario e stessa data di modifica: sono lo stesso contenuto? Possiamo calcolare l’hash. Se gli hash corrispondono, molto probabilmente i file sono identici — a meno di una collisione hash.

L’hash è un buon indicatore, ma attenzione alle collisioni, soprattutto con algoritmi datati. MD5 è rotto: è relativamente semplice creare due file diversi che producono lo stesso valore MD5. Quindi conviene usare più di un algoritmo e preferire quelli moderni e non ancora compromessi. Col tempo gli algoritmi vengono spezzati; questo è cruciale perché, per esempio, se un antivirus identifica un file benigno tramite hash e memorizza quell’hash per evitare ripetute analisi, qualcuno potrebbe creare un file malevolo con lo stesso hash per eludere il controllo. Per questo ho menzionato che esistono esempi pubblici di collisioni;

### Example: md5 collision

Unzip basc-goodwork.zip with **basc** password.

File: `sample{1,2}.elf`
Command:  `md5sum sample*`

Same hash but different content

```sh
 ./sample1.elf 
Hello, my MD5 is 3cebbe60d91ce760409bbe513593e401
./sample2.elf 
Hi, I'm a different file. Yet, my MD5 is the same ;)
```

## Example: password cracking

Unzip basc-goodwork.zip with **basc** password.

Disclaimer: se non riuscite ad eseguirli, molto probabilmente vi mancano le librerie a 32 bit.

```sh
apt install libc6-i386
qemu-i386 ./32bitfile
```

-> `restricted_area_v1`
Solution: `strings`

-> `restricted_area_v2`
Solution: `non possiamo trovare la flag con gli strumenti discussi finora. Serve tooling più potente.`

## Analyse/Reverse Machine

Il primo passo nel reverse engineering è **disassemblare** il codice:

- Input: Sequenza di byte (non leggibile)
- Output: Istruzioni assembly (basso livello ma comprensibili)
- Scopo: Trasformare dati binari in codice analizzabile


Poi possiamo provare a

1. Identificare **basic block**
- Se si inizia l'esecuzione, tutte le istruzioni vengono eseguite
- Funziona come una "macro-istruzione"
- Alcuni blocchi hanno una sola uscita (un solo punto di salto possibile), mentre altri ne hanno più di una.
- In generale, se il blocco contiene un’istruzione di confronto (come un `cmp`), allora ci saranno due uscite: una per il caso `vero` e una per il caso `falso`.
- Se la condizione è falsa, si va in un blocco; se è vera, si va in un altro.

2. Costruire **grafi di flusso**

- Descrive i collegamenti tra basic block
- Descrive le relazioni tra funzioni (chi chiama chi)
- Forniscono informazioni strutturali per l'analisi

Analizzando la forma di questi grafi, possiamo dedurre quale costrutto sorgente (in C, C++, ecc.) li ha originati.
In pratica, i compilatori generano determinati “pattern” nel CFG per strutture note — ad esempio if, while, for, switch, ecc.
Gli strumenti di reverse engineering cercano di riconoscere questi pattern per ricostruire il sorgente a partire dal binario.

Le **cross-reference** rappresentano le relazioni tra:

- Dati e codice che li utilizza
- Codice e codice che lo chiama

Esempio 

1. Partire dal messaggio "password sbagliata"
2. Identificare il codice che stampa il messaggio
3. Risalire alla funzione chiamante
4. Trovare la routine di verifica password
5. Risultato: Individuare la password o bypassare il controllo

### Ambiguità nella decompilazione

Perché perdiamo informazione decompilando? Perché diversi sorgenti differenti possono compilare nello stesso assembly. Esempio: in un’architettura a 32 bit un puntatore e un intero hanno la stessa dimensione, perciò una funzione che prende e ritorna un int può produrre esattamente lo stesso codice di una funzione che prende e ritorna un puntatore a una struttura. Quindi il decompilatore non può decidere sempre il tipo corretto.

Se funzioni che non hanno side effect e il compilatore capisce che non servono, l’ottimizzazione può eliminare il codice; il decompilatore quindi potrebbe non mostrarvi il comportamento `logico” originale.

```c
int f(x)
{
    return x+4;
}

int *g(*int p)
{
    return p+1;
}


void foo()
{
struct { int x, y; } blah;
blah.x = 1;
blah.y = 2;
}

void bar()
{
int paperino[2];
paperino[0] = 1;
paperino[1] = 2;
}
```


Di seguito uno switch con diversi case che ritornano valori diversi. 
All’inizio il compilatore genera una sequenza di if annidati.
Si cerca quindi di forzarlo a usare una jump table.

La jump table è una tabella di indirizzi: per ogni valore possibile dello switch, viene salvato l’indirizzo della sezione di codice corrispondente.
Così il programma non confronta più il valore con ogni costante (if multipli), ma salta direttamente all’indirizzo corretto usando quell’indice nella tabella.

In questo esempio, però, la tabella si trova fuori dal blocco di codice principale.
Dal punto di vista binario, ciò significa che nella sezione .text ci sono istruzioni vere e proprie, ma poi compaiono anche valori numerici (indirizzi) che non sono istruzioni: sono dati.

```c
int my_try(int x)
{   
    switch(x){
        case 0: return 3;
        break;
        case 1: return 44;
        case 2:
        case 3:
        case 4: return 100;
        break;
        case 5: return 3;
        default: return -1;
    }
}
```

Ecco dove nasce il problema:
se si disassembla l’intera sezione .text, byte dopo byte, il disassembler non può sapere automaticamente che quei byte appartengono a una tabella di indirizzi e non a codice eseguibile.
Quindi proverà a `decodificarli” come se fossero istruzioni.



### Approcci al Disassemblaggio

Gli approcci al disassemblaggio sono fondamentalmente due:

1. **Linear sweep**

Il metodo "linear sweep" significa: "inizio dall'inizio e vado avanti sequenzialmente".

Il disassemblatore parte dal primo byte della sezione e decodifica sequenzialmente ogni byte come se fosse un'istruzione. Il problema principale è che questo approccio non distingue tra codice eseguibile e dati.

Limiti:

- Continua a decodificare anche quando incontra dati (non istruzioni)
- In architettura x86 molte sequenze di byte casuali corrispondono a istruzioni valide
- Genera istruzioni spurie che non fanno parte del programma reale
- Non considera il flusso di controllo del programma

2. **Recursive traversal**

L'approccio "recursive traversal" segue il flusso di controllo del programma per decidere cosa disassemblare.

Strategia:

1. Parte dall'entry point (punto di ingresso certo)
2. Disassembla le istruzioni sequenziali fino a istruzioni di controllo del flusso
3. Quando incontra jump o call:
    - Jump: il target è codice eseguibile → disassembla anche lì
    - Call: il controllo tornerà → continua dopo la chiamata
4. Segue ricorsivamente tutti i percorsi di esecuzione possibili

Vantaggi:

- Produce risultati più coerenti
- Evita di disassemblare dati come codice
- Rispetta la struttura logica del programma
- Utilizzato da tutti i disassemblatori moderni

Limiti:

- Con il recursive traversal, invece, un problema nasce se l’analizzatore segue rami che non verranno mai eseguiti.
- Per esempio, la jump if equal è condizionale.
- Il disassemblatore ricorsivo proverà a disassemblare sia il ramo vero che quello falso.
- Ma se la condizione è sempre vera, il ramo falso non verrà mai eseguito, quindi non è realmente codice.

Ovviamente, se eseguiamo il programma, possiamo tracciare l’esecuzione e sapere con certezza quali istruzioni vengono realmente eseguite.
In quel caso, sì, conosciamo il codice esatto — ma al prezzo di dover far girare il programma, il che non è sempre sicuro o possibile.

