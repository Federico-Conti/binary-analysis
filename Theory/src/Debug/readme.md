## ELF vs DWARF


**ELF** sta per **Executable and Linkable Format**,
ed è il **formato standard dei file binari su Linux e UNIX-like** (inclusi i file eseguibili, le librerie `.so` e gli oggetti compilati `.o`).

In altre parole, **ELF è il contenitore fisico** del tuo programma compilato.


L’ELF specifica **come sono organizzate le sezioni e i segmenti** dentro un file binario, cioè:

* dove si trova il **codice macchina** (`.text`)
* dove sono i **dati statici** (`.data`, `.bss`)
* dove sono i **simboli** (`.symtab`, `.dynsym`)
* dove stanno le **informazioni di debug** (`.debug_info`, `.debug_line`, ecc.)
* come il loader deve **mappare il file in memoria**

Esempio

Puoi ispezionare la struttura ELF con:

```bash
readelf -h factorial # header
readelf -S factorial # header sections
readelf -r factorial # relocation entries

```

Qui vedi che `.debug_info` (che contiene dati DWARF!) è **una sezione dentro l’ELF**.


**DWARF** è **il formato dei dati di debug** contenuti (tipicamente) *dentro* un file ELF.

> È lo **standard che definisce come memorizzare le informazioni di debug**,
> come i nomi delle variabili, le linee di codice, le funzioni, i tipi, ecc.

DWARF permette al debugger (come **GDB**) di:

* tradurre **indirizzi di memoria → linee di codice sorgente**
* mostrare **variabili locali e parametri**
* sapere **dove sono gli stack frame**, e come accedere alle variabili
* leggere **tipi, strutture e simboli**

In breve:

> DWARF = il **contenuto** di debug
> ELF = il **contenitore** che lo ospita

---

Esempio

Compila con:

```bash
gcc -g factorial.c -o factorial
```

Ora il binario `factorial` avrà delle **sezioni DWARF** dentro l’ELF.
Puoi verificarlo con:

```bash
readelf -S factorial | grep debug
```

Tutte queste sezioni contengono dati nel **formato DWARF**.

Puoi anche ispezionarli con:

```bash
dwarfdump factorial
```

In altre parole:

* **ELF** è il formato *di file* (come `.exe` su Windows, ma più flessibile).
* **DWARF** è il formato *di debug information* contenuto dentro (se presente).
* Il **compilatore** (con `-g`) genera le informazioni DWARF.
* Il **linker** le inserisce nelle **sezioni ELF**.
* Il **debugger** (GDB, LLDB) legge DWARF *attraverso* ELF.

---



## Install GDB+GEF

```bash
sudo apt install gdb
gdb -q -ex "python print('Python support OK')" -ex quit
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
cat ~/.gdbinit
gdb factorial
```

> **Note**: The entry point of the executable is not the `main` function defined in our program. This is because the startup code, generated by the compiler/linker as part of the standard library, initializes things and then calls `main`.
> **Note**: We have both the machine code and the source code. The machine code window is always present, while the source code window is available because we compiled with full debug information (`-g`). This allows debugging at both the source and assembly levels. Without the debug information, debugging would only work at the assembly level, without source matching.

## Some Commands

- `start`
- `tbreak main`
- `continue`
- `step`: Step into a function.
- `next`: Step over a function (execute it without stepping into it).
Adding the `i` option (e.g., `stepi` or `nexti`) enables working at the assembly level instead of the source level.
- `backtrace`: Show the current call stack. (or `bt`)
- `finish`: Run until the current function returns.
- `strip`: remove symbols from executable
- `print /d n`: print variable n in decimal
- `set $eax=0x2a`: set register eax to 42
- `break fact if n == 1` : set a conditional breakpoint
- `break *0x4011a3` : set a breakpoint at address 0x4011a3
- `info breakpoints`: list breakpoints
- `break *$rdi`: set a breakpoint at the address stored in the rdi register