# Debugging

Each process operates under the illusion that it has exclusive access to the CPU and memory. Virtual address spaces create this perception, making it seem as though all memory belongs to a single process. While the memory is shared among threads within a process, each thread has its own virtual set of CPU registers.

When a process is paused, its registers can be inspected. For single-threaded processes, there is only one set of registers. For multi-threaded processes, each thread has its own set of CPU registers, while the memory remains shared. Debuggers allow you to modify registers or memory, enabling you to test different execution paths, such as altering conditions in an `if` statement.

Despite its name, a debugger does not remove bugs. Instead, it slows down execution, allowing you to observe and analyze the program's behavior step by step. This helps in identifying and understanding errors.

## Types of Debuggers

1. **Source-Level vs Assembly-Level Debuggers**  
    - Source-Level Debuggers: Operate on the source code, allowing step-by-step execution, variable inspection, and more. Example: Visual Studio.  
    - Assembly-Level Debuggers: Work directly with machine instructions, useful for binary analysis or reverse engineering. Example: GDB, which supports both levels if debug information is available.

2. **Local vs Remote Debuggers**  
    - Local Debuggers: Run on the same machine as the target program.  
    - Remote Debuggers: Analyze code on a separate device, often used for embedded systems or firmware debugging.

3. **User-Mode vs Kernel-Mode Debuggers**  
    - User-Mode Debuggers: Analyze user-space processes.  
    - Kernel-Mode Debuggers: Analyze kernel code, typically requiring remote debugging to avoid halting the entire system.

## Breakpoints

Debuggers typically allow you to set breakpoints; two kinds:

**Software breakpoints** are the most common type of breakpoints. They allow the execution to stop when a specific instruction is reached.

- Unlimited number of breakpoints can be set.
- They only work during execution (not on memory access).

**Hardware breakpoints** are more powerful but limited in number (e.g., a maximum of four on x86 architectures). They can be used not only for execution but also to:

- Halt when a specific memory cell is read or written.
- Monitor access to specific variables or buffers.

Implementing this functionality with software breakpoints would be too costly in terms of performance, so it is directly managed by the processor hardware.

When a software breakpoint is set, the debugger modifies a byte of the program at the desired location. This involves replacing the byte with the machine code `CC`, which represents the instruction:

```
INT 3
```

The `INT 3` instruction generates software interrupt number 3, specifically used to signal the operating system and debugger that a breakpoint has been reached.

Internal Process

1. The debugger saves the original byte at the breakpoint address.
2. It replaces the byte with `CC`.
3. When execution reaches this position, the processor generates an interrupt (interrupt 3).
4. The debugger gains control, restores the original byte, and adjusts the Instruction Pointer (RIP/EIP) back by 1 byte so that the next instruction executed is the original one.

If the breakpoint needs to remain active, the debugger:
- Executes a single instruction (single step).
- Re-inserts `CC` at the same location.

This ensures normal execution while keeping the breakpoint valid.

Difference from Other Interrupts

In general, the instruction to generate an interrupt is `CD` followed by the interrupt number, e.g.:

```
CD 05  â†’  INT 5
```

However, `INT 3` is a single-byte instruction (`CC`), making it more efficient for debuggers to insert and detect.

## Memory Sharing 

Software breakpoints have a significant side effect: to insert them, the debugger modifies the process memory.

Typically, the code pages of a program (e.g., `notepad.exe`) are shared among all processes running the same binary to save memory.

However, when a debugger modifies the code of a process (by inserting a `CC` instruction), that page can no longer be shared. The operating system creates a private copy of the page for that process using the copy-on-write mechanism.

Example:

- Three instances of `notepad.exe` share the same code pages.
- If one instance is debugged and a breakpoint is inserted, only that process sees the modification.
- The other instances continue executing the original code without interruption.

## Anti-Debug Techniques

Since the debugger modifies the programme code, a software can detect this by checking its memory.
For example, a program might:

- Calculate a checksum or hash of its code.
- Check for unexpected bytes (e.g., `0xCC`) in specific locations.
- Restore the original code autonomously.

These anti-debug techniques are often used in protected software or malware to hinder dynamic analysis. They allow the program to detect the presence of a debugger or even remove the breakpoints.

While uncommon in regular software, such mechanisms are prevalent in copy-protected programs and malware samples.
