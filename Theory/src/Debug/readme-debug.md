## ELF vs DWARF

**ELF** stands for **Executable and Linkable Format**,  
and it is the **standard format for binary files on Linux and UNIX-like systems** (including executables, `.so` libraries, and compiled objects `.o`).

In other words, **ELF is the physical container** of your compiled program.

The ELF specifies **how sections and segments are organized** inside a binary file, such as:

* where the **machine code** is located (`.text`)
* where the **static data** is (`.data`, `.bss`)
* where the **symbols** are (`.symtab`, `.dynsym`)
* where the **debug information** is (`.debug_info`, `.debug_line`, etc.)
* how the loader should **map the file into memory**

Example:

You can inspect the ELF structure with:

```bash
readelf -h factorial # header
readelf -S factorial # header sections
readelf -r factorial # relocation entries
readelf -l factorial # program headers
```

Here you can see that `.debug_info` (which contains DWARF data!) is **a section inside the ELF**.

**DWARF** is **the debug data format** typically contained *inside* an ELF file.

> It is the **standard that defines how to store debug information**,  
> such as variable names, code lines, functions, types, etc.

DWARF allows the debugger (like **GDB**) to:

* translate **memory addresses → source code lines**
* display **local variables and parameters**
* know **where stack frames are**, and how to access variables
* read **types, structures, and symbols**

In short:

> DWARF = the **debug content**  
> ELF = the **container** that hosts it

---

Example:

Compile with:

```bash
gcc -g factorial.c -o factorial
```

Now the `factorial` binary will have **DWARF sections** inside the ELF.  
You can verify this with:

```bash
readelf -S factorial | grep debug
```

All these sections contain data in the **DWARF format**.

You can also inspect them with:

```bash
dwarfdump factorial
```

In other words:

* **ELF** is the *file format* (like `.exe` on Windows, but more flexible).  
* **DWARF** is the *debug information format* contained inside (if present).  
* The **compiler** (with `-g`) generates the DWARF information.  
* The **linker** inserts it into the **ELF sections**.  
* The **debugger** (GDB, LLDB) reads DWARF *through* ELF.

---

## ASLR (Address Space Layout Randomization)

In modern operating systems, when a program is started, it is mapped into the process's address space at a random address.

Unless disabled, you might notice that addresses change with each program execution.

ASLR is a **security mitigation**.  
It makes it harder to exploit vulnerabilities like buffer overflows, where the attacker needs to know precise memory addresses.  
If these addresses change randomly, the attacker cannot easily predict them.

Of course, it is not an absolute protection — a very lucky attacker might guess the correct address, or repeat the attack multiple times until successful — but it significantly increases the difficulty of reliable exploits.

## Install GDB+GEF

```bash
sudo apt install gdb
gdb -q -ex "python print('Python support OK')" -ex quit
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
cat ~/.gdbinit
gdb factorial
```

> **Note**: The entry point of the executable is not the `main` function defined in our program. This is because the startup code, generated by the compiler/linker as part of the standard library, initializes things and then calls `main`.  
> **Note**: We have both the machine code and the source code. The machine code window is always present, while the source code window is available because we compiled with full debug information (`-g`). This allows debugging at both the source and assembly levels. Without the debug information, debugging would only work at the assembly level, without source matching.

## Some Commands

- `start`
- `tbreak main`
- `continue`
- `step`: Step into a function.
- `next`: Step over a function (execute it without stepping into it).  
Adding the `i` option (e.g., `stepi` or `nexti`) enables working at the assembly level instead of the source level.
- `backtrace`: Show the current call stack. (or `bt`)
- `finish`: Run until the current function returns.
- `strip`: remove symbols from executable
- `print /d n`: print variable n in decimal
- `set $eax=0x2a`: set register eax to 42
- `break fact if n == 1`: set a conditional breakpoint
- `break *0x4011a3`: set a breakpoint at address 0x4011a3
- `info breakpoints`: list breakpoints
- `break *$rdi`: set a breakpoint at the address stored in the rdi register
- `vmm`: show memory mappings
- `x/5i *56555000`: disassemble 5 instructions at address 0x56555000