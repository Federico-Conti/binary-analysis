## ELF 

Before starting:

**Compile time** is when your code is being processed by a compiler. In this context, it's talking about a compiler that is transforming your code into an executable binary.

**Load time** is when the Operating System is reading an executable from long term storage (typically a hard drive) and loading it into short term memory (RAM) from which it can be executed. Generally the hard drive is too slow to feed the CPU, so fast memory is used to store instructions/programs that the CPU is getting ready to execute. This is also when the initial memory allocation is reserved and initialized for use by the program.

**Execution time** is when a program is executing or running. The instructions are in memory and are being processed by the CPU. Additional memory may be allocated and/or deallocated at this time.

---

Executable and Linkable Format

It's the format used for:

* **Executables:** binary programs that can be executed.
* **Dynamic libraries:** modules loadable by other programs at execution time.
* **Object files:** results of compiling a single source file, typically with `.o` extension.
* **Core dumps:** memory snapshots of a process at crash time, also containing register information.
  These are used for post-mortem debugging, i.e., to analyze the process situation after a crash.

Every ELF file starts with an ELF header, which represents a kind of map of the file content.
The header can point to:

* **Section Header Table**
* **Program Header Table**

These two tables are not mandatory: an ELF file can contain only one of them.

* The **Section Header Table** describes the **sections**, and is useful in the **linking** phase.
  → Present in object files (`.o`), but often absent in executables (`.exe, .bin, .out`) → not necessary for execution.
  Even if the table is missing, sections (like `.text`) still exist: there's simply no table describing them.
* The **Program Header Table** describes the **segments**, i.e., the file portions necessary for execution.
  → Always present in executables, because it tells the operating system what must be mapped in memory and with which permissions.
  Can be absent in object files → not intended for direct execution.

The ELF header starts with 16 identifier bytes:

* The first 4 bytes are: `0x7F` followed by `E`, `L`, `F` (in ASCII).
* Various fields follow, including:
  * **Type**, **Machine**, **Version**
  * **Entry**: program entry point (where execution starts in memory (.text))
  * **PHoff**: offset in the file of the *Program Header Table*
  * **SHoff**: *Section Header Table* offset (can be 0)
  * **EI_Data**: describes the *endianness* (byte order)
  * **OS ABI**: specifies the operating system Application Binary Interface.

> All structure definitions can be found in /usr/include/elf.h
> Intel architecture is *little endian*, so ELF files on Intel are also little endian.

#### Example: hello_world

File: `hello_world-ok, hello_world_maybe_broken`.
Command: `./, readelf -h`

If we execute it, it prints "Hello World".
Using commands like `readelf -h hello_world`, we can read the ELF header and discover that the **ABI** is "UNIX System V".

Opening the file with a hexadecimal editor (`hd`), we can modify the ABI field (for example from System V to Solaris).
Even if we change this value, the program continues to work, because the Linux kernel doesn't really check that field.
The loader simply verifies that the file *looks like* an ELF, but ignores many specification details.

Two programs:

* `hello_world` → executable and debuggable;
* `hello_world_maybe_broken` → executes correctly, but GDB considers it "not executable".

Analyzing the two files (`readelf -h`), we discover they differ by only one byte.
That single byte is sufficient to make GDB reject it, while being perfectly executable by the operating system.

Solution:

- In the "broken" file, the value is 02, which indicates Big Endian, but the architecture is x86-64, which uses Little Endian. This mismatch is sufficient to make GDB analysis fail.
- Only the header has been tampered with, so if I run it, it works, but GDB also looks at the header, causing it to fail.

---

Main sections in an ELF

| Section          | Content                                    | Description                                                  |
| ---------------- | ------------------------------------------ | ------------------------------------------------------------ |
| `.text`          | machine code                               | the executable code                                          |
| `.data`          | initialized global data                    | global variables with initial value                         |
| `.rodata`        | read-only data                             | global constants                                             |
| `.bss`           | uninitialized data                         | reserved space for global variables without initial value   |
| `.init`, `.fini` | initialization and termination routines   | calls at startup or shutdown                                 |
| `.interp`        | ELF interpreter                            | specifies the interpreter to use (e.g., dynamic linker)     |
| `.plt`           | Procedure Linkage Table                    | used for calling external functions (in shared libraries)    |
| `.got`           | Global Offset Table                        | used for addressing global variables in shared libraries      |
| `.dynamic`      | dynamic linking information                | used for storing information needed for dynamic linking      |
| `.eh_frame`      | exception handling data                    | used for stack unwinding during exceptions                    |
| `.debug_*`       | debug information (DWARF format)          | used for storing debugging information                        |


The `.interp` field indicates the file interpreter, which in Linux is actually the **dynamic linker** (`ld-linux.so`).
When executing a dynamically linked program:

1. The kernel maps the ELF program in memory.
2. Also maps the dynamic linker.
3. The linker loads and initializes all necessary shared libraries.
4. Finally, passes control to the main program.



Main segments (Program Header)

| Segment           | Meaning                                   |
| ----------------- | ----------------------------------------- |
| `PT_LOAD`         | must be loaded (mapped in memory)         |
| `PT_INTERP`       | contains the ELF interpreter              |
| `PT_DYNAMIC`      | information for dynamic linking           |
| `PT_GNU_EH_FRAME` | GNU extension for exception handling      |
| `PT_GNU_STACK`    | specifies if the stack is executable or not |

> The stack **should never be executable**; today it's disabled for security reasons, but can be enabled for compatibility with old programs.

When we execute a program (e.g., `./hello_world`), the shell invokes:

1. `fork()` → creates a new child process;
2. `execve()` → replaces the child's address space with that of the ELF executable.

During `execve`, the kernel:

* Creates a new address space;
* Maps the `PT_LOAD` segments according to Program Header instructions (code, data, etc.);
* Allocates the stack and copies on it:
  * the file name,
  * the arguments (`argv`),
  * and environment variables (`envp`);
* Call the dynamic linker (if present), the kernel loads the linker indicated in the `INTERP` section.
* Starts the program at its *entry point*.

---

### Exec ELF of different architecture

If we try to execute, for example, `hello_world.arm` on an **Intel** machine, the system can still execute it if an **emulator** is installed, like **QEMU**.

Linux supports different binary formats (e.g., ELF, a.out).
When it encounters an unknown format, the kernel can **delegate execution to an external interpreter**, as in the case of QEMU for ARM.

> Disabling this support (`/proc/sys/fs/binfmt_misc`), we get the error "Exec format error".

The file extension has no importance for execution.
A `foo.gfx` file can be executed like any valid ELF, regardless of the name.
The kernel relies solely on the file's internal structure (e.g., the "magic number" 0x7F ELF), not on the extension.

### Dynamic Linking

### Shared Libraries

- [Load-time relocation of shared libraries](https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/)
- [Position Independent Code (PIC) in shared libraries](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/)

A dynamic library or shared object or shared library is a file (typically with .so extension on Linux (see ldd /bin/ls), abbreviation of shared object) that contains compiled code — functions, routines, and data — that can be used by multiple programs. Unlike static libraries (.a), it's not directly incorporated into the executable file, but linked at execution time.

- The compiler reads #include <stdio.h> → finds the printf declaration.
- The linker connects your program to libc.so → where there's the printf definition.
- The loader loads the libraries in memory.
  
---

Each program is executed in a separate memory space.
When multiple programs use the same library, the operating system can save memory by loading it only once.
The operating system can do this only if the library file content in memory is the same for all processes.
The code of the library must never be modified after being loaded in memory.

As long as the executable needs no shared libraries, it needs no relocations. But if it does use shared libraries (as do the vast majority of Linux applications), symbols taken from these shared libraries need to be relocated, because of how shared libraries are loaded.

Unlike executables, when shared libraries are being built, the linker can't assume a known load address for their code. The reason: each program can use any number of shared libraries, and there's simply no way to know in advance where any given shared library will be loaded in the process's virtual memory.

```c++
int myglob = 42;

int ml_func(int a, int b)
{
    myglob += a;
    return b + myglob;
}
```

Note how ml_func references myglob a few times. When translated to x86 assembly, this will involve a mov instruction to pull the value of myglob from its location in memory into a register. mov requires an absolute address - so how does the linker know which address to place in it? The answer is - it doesn't. **Shared libraries have no pre-defined load address - it will be decided at runtime.**

In Linux, the **dynamic loader** is a piece of code responsible for preparing programs for running. One of its tasks is to load shared libraries from disk into memory, when the running executable requests them. When a shared library is loaded into memory, it is then adjusted for its newly determined load location. It is the job of the dynamic loader to solve the problem presented in the previous paragraph.

There are two main approaches to solve this problem in Linux ELF shared libraries:

1. Load-time relocation 
2. Position independent code (PIC)

To create a shared library that has to be relocated at load-time, I'll compile it without the -fPIC flag (which would otherwise trigger PIC generation):

```bash
gcc -g -c ml_main.c -o ml_mainreloc.o
gcc -shared -o libmlreloc.so ml_mainreloc.o
```

**Load-time relocation** has a couple of problems: it takes time to perform, and it makes the text section of the library non-shareable: since when using this technique the text section has to be modified at load-time to apply the relocations.
Therefore, for each application that loaded this shared library, it will have to be wholly placed in RAM again. Different applications won't be able to really share it.

### Position Independent Code (PIC)

The idea behind PIC is simple - add an additional level of indirection to all global data and function references in the library code. By cleverly utilizing some artifacts of the linking and loading processes, it's possible to make the text section of the shared library truly position independent, in the sense that it can be easily mapped into different memory addresses without needing to change one bit.

When the linker combines several object files together, it collects their sections (for example, all text sections get unified into a single large text section).

What known to the linker at link-time:

- The offset between the text and data sections
- Offset from any given instruction in the text section to the beginning of the data section is just the size of the text section minus the offset of the instruction from the beginning of the text section

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/pic1.png}
\end{center}

So PIC must use relative addressing, generally relative to the current instruction pointer.

> Note: today, even modern executables are normally position-independent → to mitigate exploitation-type vulnerabilities


In 64-bit mode:

The processor natively supports RIP-relative addressing.

So the compiler can generate instructions like `mov rax, [rip + offset]` directly and efficiently.

In 32-bit mode:

There's no instruction that says "read at [EIP + offset]".

So we need to use a small trick, called tunking

- We make a call to a mini-function (a dummy function).
- The call instruction pushes the address of the next instruction onto the stack (i.e., the EIP value).
- The function immediately pops this value, thus obtaining the current code address.
- From there, we add an offset to reach the global variable.

Example:

```assembly
call get_ipaddr       ; saves the next instruction address on the stack

  get_ipaddr:
  pop ebx           ; ebx = current address (EIP)
add ebx, offset   ; ebx now points to data
```

It works, but it's not efficient — requires a call and stack access.

#### The Global Offset Table (GOT)

A GOT is simply a table of addresses, residing in the data section. Suppose some instruction in the code section wants to refer to a variable. Instead of referring to it directly by absolute address (which would require a relocation), it refers to an entry in the GOT. Since the GOT is in a known place in the data section, this reference is relative and known to the linker. The GOT entry, in turn, will contain the absolute address of the variable

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/pic2.png}
\end{center}

```
; 1. Somehow get the address of the GOT into ebx
lea ebx, ADDR_OF_GOT

; 2. Suppose ADDR_OF_VAR is stored at offset 0x10
;    in the GOT. Then this will place ADDR_OF_VAR
;    into edx.
mov edx, DWORD PTR [ebx + 0x10] 

; 3. Finally, access the variable and place its
;    value into edx.
mov edx, DWORD PTR [edx]
```

How does the address of [ebx + 0x10] (suppose 0x1fe4 ) actually get into the GOT slot?

So, we've gotten rid of a relocation in the code section by redirecting variable references through the GOT.

But:

1. Relocations in the code section are required per variable reference, while in the GOT we only need to relocate once per variable. There are likely much more references to variables than variables, so this is more efficient.
2. The data section is writable and not shared between processes anyway, so adding relocations to it does no harm. Moving relocations from the code section, however, allows to make it read-only and share it between processes.
For each module (L2, L3, etc.), the compiler creates a pointer table in the data section:
each entry of this table contains the real address of the external variable.

to compile with pic sharing:

```sh
gcc -fPIC -c miofile.c -o miofile.o
gcc -shared -o libmia.so miofile.o
```

to view relocation information :

```sh
readelf -r libmia.so
```

#### Function calls in PIC
The mechanism we have described so far, in which all references are resolved before the programme starts, is instead called **early binding**.

When a shared library refers to some function, the real address of that function is not known until load time. Resolving this address is called binding, and it's something the dynamic loader does when it loads the shared library into the process's memory space. This binding process is non-trivial, since the loader has to actually look up the function symbol in special tables.


in a typical run of a program only a fraction of functions actually get called (think about various functions handling error and special conditions, which typically don't get called at all).

So, to speed up this process, a clever **lazy binding** scheme was devised. "Lazy" is a generic name for a family of optimizations in computer programming, where work is delayed until the last moment when it's actually needed, with the intention of avoiding doing this work if its results are never required during a specific run of a program.

This lazy binding scheme is attained by adding yet another level of indirection - the PLT.

The PLT is part of the executable text section, consisting of a set of entries (one for each external function the shared library calls). Each PLT entry is a short chunk of executable code. Instead of calling the function directly, the code calls an entry in the PLT, which then takes care to call the actual function
Each PLT entry also has a corresponding entry in the GOT which contains the actual offset to the function, but only when the dynamic loader resolves it. 


\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/pic4.png}
\end{center}

Suppose that L2 (a library or an executable) wants to call a function foo() that is not defined within it, but in another library, L1.

In L2's code there is no direct reference to foo, but rather to a special symbol called:

foo@PLT

This is a stub (a mini-function) in the PLT.

foo@PLT does not contain the actual foo function, but a small code fragment that:

1. accesses a GOT entry (for foo),
2. reads a pointer from it (initially unresolved),
3. performs an indirect jump (i.e.: "go where this address points").

First execution: 

- the GOT entry is not yet updated
- it points to a small fragment of initialisation code which invokes the resolver of the dynamic linker.
- This resolver searches for the function, obtains its address and overwrites the GOT entry.

From the next call onwards, the function will be invoked directly via the updated address.

From the second call: 

- the pointer in the GOT has already been updated.
- So foo@PLT no longer needs to invoke the resolver
- now it simply performs a direct jump to the address of foo() stored in the GOT.

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/pic3.png}
\end{center}


It is important to note that the PLT uses a jump instruction (jmp) and not a call instruction (call).
If call were used, the function on return would return to the PLT, which would then have to return again to the original caller, resulting in two returns.
With jmp, on the other hand, the return goes directly to the caller, avoiding an intermediate return and saving execution time.

With early binding, on the other hand, all functions are resolved at start-up.
In this case, the resolver is not necessary, and the compiler can generate a 'reduced' PLT, in which the lazy binding instructions are replaced by simple no-ops (null operations) such as xchg %ax, %ax, used only to maintain the 8-byte alignment.


gcc allows to avoid the PLT, option -fno-plt, by generating:

```c++
call QWORD PTR [GOT-func ]

; instead of: 

call func@PLT
```

> Note: In modern systems, however, early binding (or re-binding) is also preferred for functions for security reasons, as it avoids certain vulnerabilities.

#### Security considerations PLT/GOT

The Global Offset Table (GOT) is a very delicate structure from a security perspective, as it contains pointers to external functions.
If an attacker manages to modify the GOT (for example by exploiting an arbitrary write vulnerability), they can redirect function calls to malicious code.

For instance, if the GOT entry that points to printf is overwritten with the address of system, an innocent call to printf can become a call to system, potentially allowing shell command execution.
This type of exploit is real and demonstrates the criticality of the GOT.

To mitigate the problem, modern systems introduce RELRO (RELocation Read-Only) protection.
The principle is to make the GOT non-writable after the initial symbol resolution.

However, if lazy binding is used, the GOT must be able to be modified every time a new function is resolved, so it cannot be made read-only immediately.
Making it temporarily writable and then protected again would be too expensive, as it would require a system call every time


Related ld options:

- `-z norelro`: don't create PT_GNU_RELRO
- `-z relro`: create PT_GNU_RELRO segment, which will be made read-only after relocation
- Full relro protection in gcc: `-z relro -z now`

With **partial RELRO** (`-z relro`), only some parts of the GOT are protected, while the part used for lazy binding remains writable.

With **full RELRO** (`-z relro -z now`), all symbols are resolved at load time (early binding), allowing the entire GOT to be made read-only. This eliminates the lazy binding optimization but provides maximum security.

#### Building PIC/PIE

**Compiler flags:**

- `-fpic`: Generate Position Independent Code (PIC), which accesses external symbols through a GOT
- `-fpie`: Similar to `-fpic`, but generated PIC can only be linked into executables; typically used with `-pie`

**Linker flags:**

- `-static`: Static linking; shared libraries are ignored
- `-shared`: Used with `-fpic` to produce a shared object
- `-pie`: Used with `-fpie` to produce an "executable" shared object → better ASLR
- `-static-pie`: (only in recent GCC) Creates a statically linked PIE

> **Be consistent** for predictable results: `-f...` flags are for the compiler, `-pie/-shared/-static` are for the linker

ELF shared objects are created using `-shared`:

```bash
gcc -shared -fpic -o libfuncs.so my-lib*.c
gcc main.c -L. -lfuncs
LD_LIBRARY_PATH=. ./a.out
```

**Library path resolution:**

- If `LD_LIBRARY_PATH` is defined, it is searched before standard library directories
- Exception: not used when the executable is set-UID/GID (security reasons)

**Production considerations:**
A production application should **never rely on `LD_LIBRARY_PATH`**. Shared libraries should be either:
1. Installed in standard directories, or
2. Located in directories specified by `DT_RUNPATH`/`DT_RPATH` inside the ELF (using `ld` option `-rpath`)

Inside `R(UN)PATH`, the special name `$ORIGIN` means "the directory containing the application" (see `ld.so(8)` for more details).

> Note
sudo is an example of a setuid executable. A setuid executable is an executable that, when run, causes the effective UID of the process to become the same as the owner of the file; typically the owner is root. Thus, when you execute a setuid owned by root, you act as root for that execution.
Now, if you could set the LD_LIBRARY_PATH for such an executable, you could start any programme (even one that prints 'hello world' with printf) and replace the printf library by searching for libc in your directories. You could create a library with the same name requested by the programme, which inside it executes malicious code (e.g. opens a shell). By starting a setuid executable that loads that library, you get an execution with root privileges. Basically, you can take standard libc, replace part of it with a backdoor, run a setuid and get the system.
This is why the LD_LIBRARY_PATH variable is ignored for setuid and setgid executables.
Obviously the use of LD_LIBRARY_PATH is useful in development, but it is not correct to ask the user to set their own LD_LIBRARY_PATH variable. Instead, it is possible to specify within the ELF a path where to look for the libraries required by the application.
Within the ELF you can use the special variable $ORIGIN, which represents the directory where the executable resides. Thus, if you distribute an application with libraries in subdirectories relative to the executable, you can set RPATH/RUNPATH using $ORIGIN/... to indicate paths relative to the installation of the program. This is the correct method for distributing binaries that require non-standard libraries.


## Implicit Dynamic Linking

The ELF contains an interpreter (the dynamic linker) and within the `PT_DYNAMIC` header there is the linking data. When the kernel launches program P, it creates the user space for P and maps the segments indicated as PT_LOAD in the executable.

If no `PT_INTERP` is specified in the ELF (i.e., there is no interpreter), execution starts directly from the program's entry point — this is the case of **static linking** (self-contained program).

In the majority of cases, however, the ELF is dynamic and contains an interpreter: in this case the kernel starts the interpreter (the dynamic linker) which then takes care of loading all necessary libraries and finally starts the entry point of the actual program.


\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/sharedlibrary.png}
\end{center}

I won't go into too much detail: the fundamental idea is this. If you want to trace the process at runtime, you can use a debugger: in gdb there is the `stop-on-solib-events` option (solib = shared object library). If you set it, gdb stops every time a new library is mapped into the process's user space; the commands `info shared`, `vmmap` or `xfiles` show which libraries have been loaded and where they are mapped.

You can ask the dynamic linker to print out what it is doing by setting the `LD_DEBUG` environment variable. In particular, `LD_DEBUG=libs` shows which libraries are being searched and loaded.
Remember that these debugging options are also ignored for setuid executables for security reasons.

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/sharedlibrary2.png}
\end{center}

## Symbol resolution

In dynamic linking, the semantics of **first definition wins** applies. If a symbol is undefined and several libraries provide different implementations (e.g. bar is defined in both libA and libB), then the first library that defines bar will provide the definition used by the programme.

This behaviour also allows **preloading techniques**: if you can get one of your libraries to be loaded before the others and define symbols that are already present, your definition overwrites those that come later.


## Library Interposition

Library interposition means we can put something between the program and the library, so as to intercept calls to library functions and execute our code instead of the original function. Obviously our code could call the original function, but maybe we want to log the arguments or return value. We can completely re-implement the function or call the original and maybe modify its return value or other aspects. We have total control over what happens. The basic idea is that the function we want to replace gets replaced by a so-called wrapper function, which must have the same signature as the original function, so that the wrapper gets called instead of the original library function.

### 2.1 Compile time level 

This is the most invasive method (replace code at compile time).

```c
/* file app.c */
#include <stdio.h>
#define printf my_printf

int main() {
  printf("hello %d\n", 42);   /* expanded to my_printf(...) */
}

/* file helper.c */
#include <stdio.h>
#undef printf
int my_printf(const char *fmt, ...) {
  ...
}
```

### 2.2 Linker level 

- No need to change sources, but you must relink (so have the object files or recompile them)
- Doesn't work on already linked binaries without rebuilding

```bash
gcc -Wl,--wrap,printf app.o wrapper.o -o app
```

Where:

```c
/* wrapper.c */
int __wrap_printf(const char *fmt, ...) {
  /* log and then call __real_printf */
}
```

### 2.3 Runtime Level (Dynamic linker API)

This is the approach that allows modifying behavior without source code and without relinking: we use the dynamic loader / runtime linker.

Two typical mechanisms:

**LD_PRELOAD (Linux/Unix)**: forces the dynamic loader to load a shared library before others; if that library defines the same symbol (e.g. printf), that definition is used instead of the one in libc.

**dlsym / dlopen**: inside a shared object (or at runtime) you can use:

```c
void *dlopen(const char *filename, int flag);
```
to open a shared library

```c
void *dlsym(void *handle, const char *symbol);
```
to retrieve a symbol.

`dlsym(RTLD_NEXT, "printf")` finds the next definition of printf in the resolution chain (useful for calling the original from a wrapper implemented with LD_PRELOAD).

The handle parameter controls where the search for the symbol takes place.

This is where the two special **pseudo-handles** come into play:

When you pass:

```c
dlsym(RTLD_DEFAULT, "F");
```

It means:

"Search for symbol F anywhere, according to the normal loading order".

So, if P doesn't define it, it's taken from L1, and only if L1 doesn't define it, it moves to L2, and so on.

When you pass:

```c
dlsym(RTLD_NEXT, "F");
```

It means:

"Search for symbol F, but starting from the next module relative to the one calling dlsym()".

This is extremely useful for those writing wrappers (as in the case of LD_PRELOAD).
It allows your wrapper to say:

"I am intercepting F, but now I want to call the original version found in the next library in the chain."

So, setting the `LD_PRELOAD` environment variable asks the dynamic linker to preload our shared object(s) before the others. This allows the definition of any library function to be overridden: if I convince the loader to load my library before the libc, I can implement any function that the libc implements and the programme will use my version.

[Symbiote malware](https://blogs.blackberry.com/en/2022/06/symbiote-a-new-nearly-impossible-to-detect-linux-threat)

Since this technique is very powerful, LD_PRELOAD is ignored for set-user-id and set-group-id (setuid/setgid) programmes for security reasons: if it were applicable to those programmes, I could replace any function with one that opens a privileged shell and obtain administrative privileges by running the vulnerable programme.

#### Example

File used: `my_strcmp.c`, `check_serial.c`
Commands used: `make`, `ltrace ./check_serial 1234`

Explanation:

Let's see a concrete example. Suppose we have a program that verifies a serial number and to do this it compares strings: it most likely uses strcmp. The strcmp manpage says it takes two strings and returns zero if they are equal, negative if the first is "less" than the second in lexicographic order, positive otherwise. I can intercept this function by providing my own implementation with the same signature as strcmp (same arguments, same return value). If I still want to call the real strcmp I need to get a pointer to the real function: this is obtained with dlsym(RTLD_NEXT, "strcmp"), so as to avoid getting a pointer to my own function (since I'm redefining strcmp). The function pointer declaration may seem unreadable: it's a pointer to a function that takes two const char * and returns an int. If you remove the right parentheses you change the meaning (it becomes a function that returns a pointer, etc.), so the parentheses around the name are necessary to indicate pointer to function. You can then call the function through the pointer and, before or after calling the real function, log arguments and result. You can also cheat: for example you could always return 0, so even if the strings are different the caller will think they are equal and the serial number check will be passed, if the interposition has been applied correctly.

### Example: antidebug

File used: `antidebug{1,2}`
Commands used: `strace ./antidebug1`

`strace` is a command that allows you to see the system calls executed by a program during its execution.
It is useful to understand the programme's interaction with the operating system, but is not always reliable: some versions do not work with 32-bit executables or with compressed (packed) executables.

**antidebug1** 

Something suspicious:

- If I run `./antidebug1` it prints `I'm evil`
- If I try to understand what's happening with `strace ./antidebug1` and `gdb ./antidebug1` I get `hello world`.

The program detects that it's being observed and changes behavior. This is used to simulate how some malware works: if the malware realizes it's in an analysis environment (sandbox, debugger), it doesn't execute the malicious payload, thus evading analysis; when it's executed on a real machine, it performs the damage (e.g., file encryption).

There are two other examples: the spoiler is that the third one can be solved with the tools seen so far, while the others require more advanced tools that we'll see later.

Solution:

The program uses the `ptrace` system call to detect if it's being traced. `ptrace` is used by debuggers to control a process; if a process tries to call `ptrace` with `PTRACE_TRACEME` and it's already being traced, the call fails with `EPERM` (operation not permitted). So, by calling `ptrace(PTRACE_TRACEME)` and checking the return value, the program can determine if it's being debugged.

```sh
strace ./antidebug1 2>&1 | grep ptrace
ptrace(PTRACE_TRACEME)                  = -1 EPERM (Operation not permitted)
```

Or you can see it from:

```sh
gef> start
gef> disassemble main
   0x0000555555555185 <+28>:    mov    eax,0x0 ; initializes the return value to 0
   0x000055555555518a <+33>:    call   0x555555555070  ; to check
   0x000055555555518f <+38>:    cmp    rax,0xffffffffffffffff ; compares the return with -1
  
gef> break *0x555555555070
run # <ptrace@got.plt>
```

The program makes a call to `ptrace(PTRACE_TRACEME, ...)` to detect if it is already being traced/debugged:

- If that call succeeds, the program continues and executes the "malicious" branch ("I'm evil!!!").
- If that call fails (returns -1/EPERM), the program assumes it is being debugged and instead executes the "innocent" branch ("Hello world!").

Objective: Always print "I'm evil!!!", even if under `strace` or `gdb`.

Create a fake ptrace that overwrites ptrace and only returns 0:
Then we do the library override with LD_PRELOAD where?

- not "global" because otherwise we break gdb --> gdb itself uses the ptrace syscall for debugging
-  but inside gdb itself we do the override --> so gdb has already been called to debug the program and therefore the ptrace call inside gdb works normally

```c
// pippo.c
//  gcc -shared -fPIC -O2 -o pippo.so pippo.c 
long ptrace(int request, ...) {
    
    return 0;
}
```

Compile and use gdb with LD_PRELOAD:

```sh
gdb antidebug1

set env LD_PRELOAD ./pippo.so
run
I’m evil!!! # now not hiide the evil behavior
```

**antidebug2**

here syscall calls ptrace
Acting as before does not work because the program now directly called syscall and then ptrace

Some clarification:

- The use of directly calling syscall() is because many wrapper functions are not used in libc
- ptrace() already has the official wrapper in libc so it would be useless to call syscall


```sh
gef>  start
gef>  disassemble main
   0x0000555555555186 <+29>:    mov    edi,0x65 ; 101 = SYS_ptrace
   0x000055555555518b <+34>:    mov    eax,0x0
   0x0000555555555190 <+39>:    call   0x555555555070 ; to check

gef> break *0x555555555070
run #  <syscall@got.plt>
```

I create a fake syscall that intercepts the call to syscall and if the syscall number is 101 (ptrace) returns 0, otherwise calls the real syscall.

```c
// pippo.c
//  gcc -shared -fPIC -O2 -o pippo.so pippo.c 
#define _GNU_SOURCE
#include <stdio.h>
#include <stdarg.h>
#include <dlfcn.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <sys/types.h>
#include <unistd.h>
#include <sys/syscall.h>

long syscall(long number, ...) {
    static long (*real_syscall)(long number, ...) = 0;

    if (!real_syscall)
        real_syscall = dlsym(RTLD_NEXT, "syscall");
    if (!real_syscall) {
        fprintf(stderr, "Cannot hook syscall!\n");
        _exit(EXIT_FAILURE);
    }

    if (number == SYS_ptrace) {
        printf("Ahah my ptrace has been called\n");
        return 0;
    }
//optional: handle up to 6 arguments
    va_list args;
    va_start(args, number);
    long a1 = va_arg(args, long);
    long a2 = va_arg(args, long);
    long a3 = va_arg(args, long);
    long a4 = va_arg(args, long);
    long a5 = va_arg(args, long);
    long a6 = va_arg(args, long);
    va_end(args);

    return real_syscall(number, a1, a2, a3, a4, a5, a6);

}
```

Compile and use gdb with LD_PRELOAD:

```sh
gdb antidebug1

set env LD_PRELOAD ./pippo.so
run
I’m evil!!! # now not hiide the evil behavior
```

In C, you can receive a variable number of arguments using `...` and `va_list`, but you cannot automatically pass all the received arguments to another function. This limitation requires manual handling of arguments when forwarding them.

For example, in the case of Linux on 64-bit systems, all system calls have a maximum of 6 arguments. This means:

- You could handle only the specific case used in the exercise (e.g., a syscall with a fixed number of arguments).
- Alternatively, you could write a more robust version, such as one with 6 fixed parameters, which works in all cases.


## Dependency Resolution and Loading Order

Each module (executable or shared object) declares dependencies (DT_NEEDED): "I depend on A, B, C".

The loader constructs the dependency graph and performs a topological sort: it loads/initializes modules without dependencies first, then those that depend on them, ensuring that each module finds its dependencies already ready.

This order affects symbol resolution: what is loaded/initialized first has priority in standard search, and constructor routines of modules loaded earlier can install hooks, modify global state, etc.


\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/resoltion.png}
\end{center}

**Initialization** occurs forward according to the order determined by the topological sort; 
**finalization** (when unloading) occurs in reverse order (LIFO).

This ensures that dependencies remain valid throughout the execution of code that uses them: a library is destroyed after all modules that use it.

For modules loaded via dlopen at runtime: their init routines are executed at the time of dlopen (unless you specify particular flags), and the fini routines at dlclose when the reference count drops to zero.

Where these routines are registered in ELF

- `.preinit_array` — functions to invoke before normal initialization (mainly in the executable).
- `.init_array` — array of pointers to functions to invoke at startup (constructors).
- `.fini_array` — array executed at termination (destructors).
- `DT_INIT` / `DT_FINI` (older entrypoints) still exist for compatibility but `.init_array`/`.fini_array` is the modern standard.

### Example

```c
#include <stdio.h>

__attribute__((constructor))
static void my_init(void) {
    /* eseguita prima di main (dopo le init della libc) */
    fprintf(stderr, ">>> my_init executed\n");
}

__attribute__((destructor))
static void my_fini(void) {
    /* eseguita alla terminazione (prima di uscire) */
    fprintf(stderr, ">>> my_fini executed\n");
}

int main(void) {
    puts("in main");
    return 0;
}
```

```bash
$ ./a.out
>>> my_init executed
in main
>>> my_fini executed
```
