## ELF 

Before starting:

**Compile time** is when your code is being processed by a compiler. In this context, it's talking about a compiler that is transforming your code into an executable binary.

**Load time** is when the Operating System is reading an executable from long term storage (typically a hard drive) and loading it into short term memory (RAM) from which it can be executed. Generally the hard drive is too slow to feed the CPU, so fast memory is used to store instructions/programs that the CPU is getting ready to execute. This is also when the initial memory allocation is reserved and initialized for use by the program.

**Execution time** is when a program is executing or running. The instructions are in memory and are being processed by the CPU. Additional memory may be allocated and/or deallocated at this time.

---

Executable and Linkable Format

It's the format used for:

* **Executables:** binary programs that can be executed.
* **Dynamic libraries:** modules loadable by other programs at execution time.
* **Object files:** results of compiling a single source file, typically with `.o` extension.
* **Core dumps:** memory snapshots of a process at crash time, also containing register information.
  These are used for post-mortem debugging, i.e., to analyze the process situation after a crash.

Every ELF file starts with an ELF header, which represents a kind of map of the file content.
The header can point to:

* **Section Header Table**
* **Program Header Table**

These two tables are not mandatory: an ELF file can contain only one of them.

* The **Section Header Table** describes the **sections**, and is useful in the **linking** phase.
  → Present in object files (`.o`), but often absent in executables (`.exe, .bin, .out`) → not necessary for execution.
  Even if the table is missing, sections (like `.text`) still exist: there's simply no table describing them.
* The **Program Header Table** describes the **segments**, i.e., the file portions necessary for execution.
  → Always present in executables, because it tells the operating system what must be mapped in memory and with which permissions.
  Can be absent in object files → not intended for direct execution.

The ELF header starts with 16 identifier bytes:

* The first 4 bytes are: `0x7F` followed by `E`, `L`, `F` (in ASCII).
* Various fields follow, including:
  * **Type**, **Machine**, **Version**
  * **Entry**: program entry point (where execution starts in memory (.text))
  * **PHoff**: offset in the file of the *Program Header Table*
  * **SHoff**: *Section Header Table* offset (can be 0)
  * **EI_Data**: describes the *endianness* (byte order)
  * **OS ABI**: specifies the operating system Application Binary Interface.

> All structure definitions can be found in /usr/include/elf.h
> Intel architecture is *little endian*, so ELF files on Intel are also little endian.

#### Example

Consider a simple `hello_world` program.
If we execute it, it prints "Hello World".
Using commands like `readelf -h hello_world`, we can read the ELF header and discover that the **ABI** is "UNIX System V".

Opening the file with a hexadecimal editor (`hd`), we can modify the ABI field (for example from System V to Solaris).
Even if we change this value, the program continues to work, because the Linux kernel doesn't really check that field.
The loader simply verifies that the file *looks like* an ELF, but ignores many specification details.

Two programs:

* `hello_world` → executable and debuggable;
* `hello_world_maybe_broken` → executes correctly, but GDB considers it "not executable".

Analyzing the two files (`readelf -h`), we discover they differ by only one byte.
That single byte is sufficient to make GDB reject it, while being perfectly executable by the operating system.

> In the "broken" file, the value is 02, which indicates Big Endian, but the architecture is x86-64, which uses Little Endian. This mismatch is sufficient to make GDB analysis fail.

---

Main sections in an ELF

| Section          | Content                                    | Description                                                  |
| ---------------- | ------------------------------------------ | ------------------------------------------------------------ |
| `.text`          | machine code                               | the executable code                                          |
| `.data`          | initialized global data                    | global variables with initial value                         |
| `.rodata`        | read-only data                             | global constants                                             |
| `.bss`           | uninitialized data                         | reserved space for global variables without initial value   |
| `.init`, `.fini` | initialization and termination routines   | calls at startup or shutdown                                 |
| `.interp`        | ELF interpreter                            | specifies the interpreter to use (e.g., dynamic linker)     |
| `.plt`           | Procedure Linkage Table                    | used for calling external functions (in shared libraries)    |
| `.got`           | Global Offset Table                        | used for addressing global variables in shared libraries      |
| `.dynamic`      | dynamic linking information                | used for storing information needed for dynamic linking      |
| `.eh_frame`      | exception handling data                    | used for stack unwinding during exceptions                    |
| `.debug_*`       | debug information (DWARF format)          | used for storing debugging information                        |


The `.interp` field indicates the file interpreter, which in Linux is actually the **dynamic linker** (`ld-linux.so`).
When executing a dynamically linked program:

1. The kernel maps the ELF program in memory.
2. Also maps the dynamic linker.
3. The linker loads and initializes all necessary shared libraries.
4. Finally, passes control to the main program.



Main segments (Program Header)

| Segment           | Meaning                                   |
| ----------------- | ----------------------------------------- |
| `PT_LOAD`         | must be loaded (mapped in memory)         |
| `PT_INTERP`       | contains the ELF interpreter              |
| `PT_DYNAMIC`      | information for dynamic linking           |
| `PT_GNU_EH_FRAME` | GNU extension for exception handling      |
| `PT_GNU_STACK`    | specifies if the stack is executable or not |

> The stack **should never be executable**; today it's disabled for security reasons, but can be enabled for compatibility with old programs.

When we execute a program (e.g., `./hello_world`), the shell invokes:

1. `fork()` → creates a new child process;
2. `execve()` → replaces the child's address space with that of the ELF executable.

During `execve`, the kernel:

* Creates a new address space;
* Maps the `PT_LOAD` segments according to Program Header instructions (code, data, etc.);
* Allocates the stack and copies on it:
  * the file name,
  * the arguments (`argv`),
  * and environment variables (`envp`);
* Call the dynamic linker (if present), the kernel loads the linker indicated in the `INTERP` section.
* Starts the program at its *entry point*.

---

### Exec ELF of different architecture

If we try to execute, for example, `hello_world.arm` on an **Intel** machine, the system can still execute it if an **emulator** is installed, like **QEMU**.

Linux supports different binary formats (e.g., ELF, a.out).
When it encounters an unknown format, the kernel can **delegate execution to an external interpreter**, as in the case of QEMU for ARM.

> Disabling this support (`/proc/sys/fs/binfmt_misc`), we get the error "Exec format error".

The file extension has no importance for execution.
A `foo.gfx` file can be executed like any valid ELF, regardless of the name.
The kernel relies solely on the file's internal structure (e.g., the "magic number" 0x7F ELF), not on the extension.

### Dynamic Linking

### Shared Libraries

- [Load-time relocation of shared libraries](https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/)
- [Position Independent Code (PIC) in shared libraries](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/)

A dynamic library or shared object or shared library is a file (typically with .so extension on Linux (see ldd /bin/ls), abbreviation of shared object) that contains compiled code — functions, routines, and data — that can be used by multiple programs. Unlike static libraries (.a), it's not directly incorporated into the executable file, but linked at execution time.

- The compiler reads #include <stdio.h> → finds the printf declaration.
- The linker connects your program to libc.so → where there's the printf definition.
- The loader loads the libraries in memory.
  
---

Each program is executed in a separate memory space.
When multiple programs use the same library, the operating system can save memory by loading it only once.
The operating system can do this only if the library file content in memory is the same for all processes.
The code of the library must never be modified after being loaded in memory.

As long as the executable needs no shared libraries, it needs no relocations. But if it does use shared libraries (as do the vast majority of Linux applications), symbols taken from these shared libraries need to be relocated, because of how shared libraries are loaded.

Unlike executables, when shared libraries are being built, the linker can't assume a known load address for their code. The reason: each program can use any number of shared libraries, and there's simply no way to know in advance where any given shared library will be loaded in the process's virtual memory.

```c++
int myglob = 42;

int ml_func(int a, int b)
{
    myglob += a;
    return b + myglob;
}
```

Note how ml_func references myglob a few times. When translated to x86 assembly, this will involve a mov instruction to pull the value of myglob from its location in memory into a register. mov requires an absolute address - so how does the linker know which address to place in it? The answer is - it doesn't. **Shared libraries have no pre-defined load address - it will be decided at runtime.**

In Linux, the **dynamic loader** is a piece of code responsible for preparing programs for running. One of its tasks is to load shared libraries from disk into memory, when the running executable requests them. When a shared library is loaded into memory, it is then adjusted for its newly determined load location. It is the job of the dynamic loader to solve the problem presented in the previous paragraph.

There are two main approaches to solve this problem in Linux ELF shared libraries:

1. Load-time relocation 
2. Position independent code (PIC)

To create a shared library that has to be relocated at load-time, I'll compile it without the -fPIC flag (which would otherwise trigger PIC generation):

```bash
gcc -g -c ml_main.c -o ml_mainreloc.o
gcc -shared -o libmlreloc.so ml_mainreloc.o
```

**Load-time relocation** has a couple of problems: it takes time to perform, and it makes the text section of the library non-shareable: since when using this technique the text section has to be modified at load-time to apply the relocations.
Therefore, for each application that loaded this shared library, it will have to be wholly placed in RAM again. Different applications won't be able to really share it.

### Position Independent Code (PIC)

The idea behind PIC is simple - add an additional level of indirection to all global data and function references in the library code. By cleverly utilizing some artifacts of the linking and loading processes, it's possible to make the text section of the shared library truly position independent, in the sense that it can be easily mapped into different memory addresses without needing to change one bit.

When the linker combines several object files together, it collects their sections (for example, all text sections get unified into a single large text section).

What known to the linker at link-time:

- The offset between the text and data sections
- Offset from any given instruction in the text section to the beginning of the data section is just the size of the text section minus the offset of the instruction from the beginning of the text section

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/pic1.png}
\end{center}

So PIC must use relative addressing, generally relative to the current instruction pointer.

> Note: today, even modern executables are normally position-independent → to mitigate exploitation-type vulnerabilities


In 64-bit mode:

The processor natively supports RIP-relative addressing.

So the compiler can generate instructions like `mov rax, [rip + offset]` directly and efficiently.

In 32-bit mode:

There's no instruction that says "read at [EIP + offset]".

So we need to use a small trick, called tunking

- We make a call to a mini-function (a dummy function).
- The call instruction pushes the address of the next instruction onto the stack (i.e., the EIP value).
- The function immediately pops this value, thus obtaining the current code address.
- From there, we add an offset to reach the global variable.

Example:

```assembly
call get_ipaddr       ; saves the next instruction address on the stack

  get_ipaddr:
  pop ebx           ; ebx = current address (EIP)
add ebx, offset   ; ebx now points to data
```

It works, but it's not efficient — requires a call and stack access.

#### The Global Offset Table (GOT)

A GOT is simply a table of addresses, residing in the data section. Suppose some instruction in the code section wants to refer to a variable. Instead of referring to it directly by absolute address (which would require a relocation), it refers to an entry in the GOT. Since the GOT is in a known place in the data section, this reference is relative and known to the linker. The GOT entry, in turn, will contain the absolute address of the variable

\begin{center}
\includegraphics[width=0.4 \linewidth]{./media/pic2.png}
\end{center}

```
; 1. Somehow get the address of the GOT into ebx
lea ebx, ADDR_OF_GOT

; 2. Suppose ADDR_OF_VAR is stored at offset 0x10
;    in the GOT. Then this will place ADDR_OF_VAR
;    into edx.
mov edx, DWORD PTR [ebx + 0x10] 

; 3. Finally, access the variable and place its
;    value into edx.
mov edx, DWORD PTR [edx]
```

How does the address of [ebx + 0x10] (suppose 0x1fe4 ) actually get into the GOT slot?

So, we've gotten rid of a relocation in the code section by redirecting variable references through the GOT.

But:

1. Relocations in the code section are required per variable reference, while in the GOT we only need to relocate once per variable. There are likely much more references to variables than variables, so this is more efficient.
2. The data section is writable and not shared between processes anyway, so adding relocations to it does no harm. Moving relocations from the code section, however, allows to make it read-only and share it between processes.
For each module (L2, L3, etc.), the compiler creates a pointer table in the data section:
each entry of this table contains the real address of the external variable.

to compile with pic sharing:

```sh
gcc -fPIC -c miofile.c -o miofile.o
gcc -shared -o libmia.so miofile.o
```

to view relocation information :

```sh
readelf -r libmia.so
```

#### Function calls in PIC
