# Vulnerabilities 

## PyGoat: An Intentionally Vulnerable Python Web Application

PyGoat is a Python web application designed to be intentionally vulnerable to security attacks. You can find its source code on [GitHub](https://github.com/eyedee2k/pygoat-tm).

---

## Mixing Code and User-Provided Data

To mitigate security issues caused by mixing code and user-provided data, consider the following best practices:

1. **Sanitize/Escape Data**: Ensure that all user inputs are properly sanitized or escaped.
2. **Use Standard Functions**: Avoid creating custom solutions. Instead, rely on standard, well-tested functions. For example:
    - Be cautious of vulnerabilities like [htmlspecialchars vulnerability (CVE-2009-4142)](https://www.cvedetails.com/cve/CVE-2009-4142/).

3. **Use Compiled Queries**: Leverage compiled queries to prevent SQL injection attacks.
4. **Adopt Domain-Specific Libraries/Frameworks**: Use libraries or frameworks tailored to your domain, such as:
    - [Entity Framework (EF)](https://msdn.microsoft.com/en-us/data/ef.aspx)
    - [SQLAlchemy](https://www.sqlalchemy.org/)

---

## Testing for Vulnerabilities

You can use tools like [sqlmap](https://sqlmap.org/) to test your application for SQL injection vulnerabilities and other security issues.


## Identifying Vulnerabilities

There are many techniques and tools. As in the case of reverse engineering, the two main categories are dynamic analysis and static analysis.

1. **Dynamic Analysis**: This involves executing the code and observing its behavior.

2. **Static Analysis**: This involves analyzing the code without executing it.

Each approach has pros and cons.  
Dynamic analysis is easier to set up: you just need to run the program and observe what it does. The advantage is that it does not produce false positives: if the tool reports a problem, there is indeed a problem. In theory, there are no false negatives either, but only if all parts of the code are actually executed. For example, if the program has 100 functions but only 10 are used in a single execution, the analysis cannot say anything about the remaining 90. Therefore, 100% code coverage is required, which is difficult to achieve. Additionally, monitored execution is slower because the tool must continuously check the program's operations.

Static analysis, on the other hand, does not require the code to be executable or fully compilable: it can work on incomplete fragments. However, it can produce both false positives (reports of non-existent problems) and false negatives (real problems not detected).

### Dynamic Analysis 

Dynamic analysis tools work by

1. (statically or dynamically) instrumenting the target application
2. observing an execution to detect errors

Major players: Valgrind, Dr.Memory and clang/gcc sanitizer

**Valgrind**

- A dynamic analysis framework for Linux.
- Executes unmodified binaries.
- Detects:
    - Memory errors (e.g., overflow, use-after-free, double free).
    - Threading errors (e.g., data races).
- **Disadvantage**: Slows execution by 20–30×.
- **Advantage**: Does not require recompilation, excellent for binary analysis.

**Dr. Memory**

- Similar to Valgrind but supports Windows and macOS.
- Faster and comparable in capabilities.

#### Sanitizers

- Tools integrated into compilers (Clang, GCC, Visual Studio) that inject runtime checks into compiled code to detect errors.
- Require source code to function.

| Sanitizer                              | Purpose                                | Examples of Detected Errors                              |
| -------------------------------------- | -------------------------------------- | ------------------------------------------------------- |
| **AddressSanitizer (ASan)**            | Checks memory access                   | Buffer overflow, use-after-free, double free, memory leaks |
| **MemorySanitizer (MSan)**             | Detects uninitialized memory usage     | Reads from uninitialized variables                     |
| **ThreadSanitizer (TSan)**             | Analyzes concurrency issues            | Data races, unsynchronized thread access               |
| **UndefinedBehaviorSanitizer (UBSan)** | Identifies undefined behaviors         | Integer overflows, division by zero, null pointers     |

Features:

- Add "red zones" around memory areas to detect illegal access.
- Maintain a shadow map to track memory cell states (valid, free, or forbidden).
- Slow execution (2–3× slower) but highly accurate.
- Provide detailed stack traces to locate the root cause of bugs.
- Advanced version: HWASan (Hardware-Assisted AddressSanitizer) uses hardware memory tagging for better efficiency.

---

#### Fuzz Testing (Fuzzers)

[Fuzz testing](https://www.fuzzingbook.org/) involves sending large amounts of random or mutated input to a program and observing if it crashes. It does not necessarily require source code.

Main Approaches:

1. **Random Fuzzing**: Sends completely random input (simple but less effective).
2. **Grammar-Based Fuzzing**: Generates valid input based on the program's expected grammar (e.g., file format).
3. **Mutation-Based Fuzzing**: Starts with valid input and modifies it randomly (more realistic).
4. **Coverage-Guided Fuzzing**: Uses code coverage to evolve inputs and explore untested code paths (most effective).

Tools:

| Fuzzer                       | Description                                                                                      |
| ---------------------------- | ------------------------------------------------------------------------------------------------ |
| **AFL (American Fuzzy Lop)** | Coverage-based fuzzer; mutates input based on reached code paths.                                |
| **AFL++**                    | Modern, enhanced version of AFL, actively maintained.                                            |
| **LibFuzzer**                | Integrated into LLVM; uses coverage-guided fuzzing as a library.                                 |
| **OSS-Fuzz (Google)**        | Cloud infrastructure combining multiple fuzzers to test open-source projects at scale.           |

Features:

- Fully automated: Provide a program and an initial input set.
- Can detect crashes or vulnerabilities that static analysis might miss.
- Widely used in the industry (e.g., Google uses fuzzers to test Chrome).

---

### Static Analysis

Tools:

**Cppcheck**  
A static analyzer for C and C++. Easy to use and available in major Linux distributions.

**Clang Static Analyzer**  
Much more advanced.  
Used with `scan-build` to monitor the compilation process and generates a report viewable with `scan-view`.  
Numbered messages show the logical path leading to a vulnerability.  
For example, if two variables point to the same memory area and both are freed, the tool flags a double free.

**PVS-Studio**  
A commercial tool (free for students and open-source projects).  
It flags vulnerabilities and classifies their severity.  
For example: “copying from an unsafe source (user input) to a fixed-size buffer.”

**Infer (Meta/Facebook)**  
A static analyzer developed by Meta (formerly Facebook). It analyzes code and finds errors like null pointer dereferences.

**Semgrep (Semantic Grep)**  
A modern analyzer that searches for semantic patterns in code.  
It can find not only identical expressions but also equivalent variants (e.g., variables with different names but the same logic).  
Useful for finding known vulnerability patterns or defining custom patterns.

**Joern and CodeQL**  
These tools are based on semantic queries.  
They allow you to write queries to find code fragments matching specific logical structures.  
For example, a query can search for all string concatenations involving unsanitized user input, useful for finding SQL injection vulnerabilities.
